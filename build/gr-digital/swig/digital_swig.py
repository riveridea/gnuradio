# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_digital_swig', [dirname(__file__)])
        except ImportError:
            import _digital_swig
            return _digital_swig
        if fp is not None:
            try:
                _mod = imp.load_module('_digital_swig', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _digital_swig = swig_import_helper()
    del swig_import_helper
else:
    import _digital_swig
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    """Proxy of C++ swig::SwigPyIterator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _digital_swig.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(self) -> PyObject"""
        return _digital_swig.SwigPyIterator_value(self)

    def incr(self, n = 1):
        """incr(self, size_t n = 1) -> SwigPyIterator"""
        return _digital_swig.SwigPyIterator_incr(self, n)

    def decr(self, n = 1):
        """decr(self, size_t n = 1) -> SwigPyIterator"""
        return _digital_swig.SwigPyIterator_decr(self, n)

    def distance(self, *args, **kwargs):
        """distance(self, SwigPyIterator x) -> ptrdiff_t"""
        return _digital_swig.SwigPyIterator_distance(self, *args, **kwargs)

    def equal(self, *args, **kwargs):
        """equal(self, SwigPyIterator x) -> bool"""
        return _digital_swig.SwigPyIterator_equal(self, *args, **kwargs)

    def copy(self):
        """copy(self) -> SwigPyIterator"""
        return _digital_swig.SwigPyIterator_copy(self)

    def next(self):
        """next(self) -> PyObject"""
        return _digital_swig.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(self) -> PyObject"""
        return _digital_swig.SwigPyIterator___next__(self)

    def previous(self):
        """previous(self) -> PyObject"""
        return _digital_swig.SwigPyIterator_previous(self)

    def advance(self, *args, **kwargs):
        """advance(self, ptrdiff_t n) -> SwigPyIterator"""
        return _digital_swig.SwigPyIterator_advance(self, *args, **kwargs)

    def __eq__(self, *args, **kwargs):
        """__eq__(self, SwigPyIterator x) -> bool"""
        return _digital_swig.SwigPyIterator___eq__(self, *args, **kwargs)

    def __ne__(self, *args, **kwargs):
        """__ne__(self, SwigPyIterator x) -> bool"""
        return _digital_swig.SwigPyIterator___ne__(self, *args, **kwargs)

    def __iadd__(self, *args, **kwargs):
        """__iadd__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _digital_swig.SwigPyIterator___iadd__(self, *args, **kwargs)

    def __isub__(self, *args, **kwargs):
        """__isub__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _digital_swig.SwigPyIterator___isub__(self, *args, **kwargs)

    def __add__(self, *args, **kwargs):
        """__add__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _digital_swig.SwigPyIterator___add__(self, *args, **kwargs)

    def __sub__(self, *args):
        """
        __sub__(self, ptrdiff_t n) -> SwigPyIterator
        __sub__(self, SwigPyIterator x) -> ptrdiff_t
        """
        return _digital_swig.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _digital_swig.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SNR_EST_SIMPLE = _digital_swig.SNR_EST_SIMPLE
SNR_EST_SKEW = _digital_swig.SNR_EST_SKEW
SNR_EST_M2M4 = _digital_swig.SNR_EST_M2M4
SNR_EST_SVR = _digital_swig.SNR_EST_SVR
class gri_control_loop(object):
    """Proxy of C++ gri_control_loop class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, float loop_bw, float max_freq, float min_freq) -> gri_control_loop"""
        this = _digital_swig.new_gri_control_loop(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _digital_swig.delete_gri_control_loop
    __del__ = lambda self : None;
    def update_gains(self):
        """update_gains(self)"""
        return _digital_swig.gri_control_loop_update_gains(self)

    def advance_loop(self, *args, **kwargs):
        """advance_loop(self, float error)"""
        return _digital_swig.gri_control_loop_advance_loop(self, *args, **kwargs)

    def phase_wrap(self):
        """phase_wrap(self)"""
        return _digital_swig.gri_control_loop_phase_wrap(self)

    def frequency_limit(self):
        """frequency_limit(self)"""
        return _digital_swig.gri_control_loop_frequency_limit(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """set_loop_bandwidth(self, float bw)"""
        return _digital_swig.gri_control_loop_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """set_damping_factor(self, float df)"""
        return _digital_swig.gri_control_loop_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """set_alpha(self, float alpha)"""
        return _digital_swig.gri_control_loop_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """set_beta(self, float beta)"""
        return _digital_swig.gri_control_loop_set_beta(self, *args, **kwargs)

    def set_frequency(self, *args, **kwargs):
        """set_frequency(self, float freq)"""
        return _digital_swig.gri_control_loop_set_frequency(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """set_phase(self, float phase)"""
        return _digital_swig.gri_control_loop_set_phase(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """get_loop_bandwidth(self) -> float"""
        return _digital_swig.gri_control_loop_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """get_damping_factor(self) -> float"""
        return _digital_swig.gri_control_loop_get_damping_factor(self)

    def get_alpha(self):
        """get_alpha(self) -> float"""
        return _digital_swig.gri_control_loop_get_alpha(self)

    def get_beta(self):
        """get_beta(self) -> float"""
        return _digital_swig.gri_control_loop_get_beta(self)

    def get_frequency(self):
        """get_frequency(self) -> float"""
        return _digital_swig.gri_control_loop_get_frequency(self)

    def get_phase(self):
        """get_phase(self) -> float"""
        return _digital_swig.gri_control_loop_get_phase(self)

gri_control_loop_swigregister = _digital_swig.gri_control_loop_swigregister
gri_control_loop_swigregister(gri_control_loop)

class digital_chunks_to_symbols_bf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_chunks_to_symbols_bf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_chunks_to_symbols_bf_sptr
        __init__(self,  p) -> digital_chunks_to_symbols_bf_sptr
        """
        this = _digital_swig.new_digital_chunks_to_symbols_bf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_chunks_to_symbols_bf_sptr
    __del__ = lambda self : None;
    def D(self):
        """D(self) -> int"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_D(self)

    def symbol_table(self):
        """symbol_table(self) -> __dummy_4__"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_symbol_table(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_bf_sptr_check_topology(self, *args, **kwargs)

digital_chunks_to_symbols_bf_sptr_swigregister = _digital_swig.digital_chunks_to_symbols_bf_sptr_swigregister
digital_chunks_to_symbols_bf_sptr_swigregister(digital_chunks_to_symbols_bf_sptr)

digital_chunks_to_symbols_bf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def chunks_to_symbols_bf(*args, **kwargs):
  """
    chunks_to_symbols_bf(__dummy_4__ symbol_table, int D = 1) -> digital_chunks_to_symbols_bf_sptr

    Map a stream of symbol indexes (unpacked bytes or shorts) to stream of float or complex constellation points in D dimensions (D = 1 by default)

    input: stream of unsigned char; output: stream of float.

    out[n D + k] = symbol_table[in[n] D + k], k=0,1,...,D-1

    The combination of gr_packed_to_unpacked_XX followed by gr_chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.
    """
  return _digital_swig.chunks_to_symbols_bf(*args, **kwargs)
class digital_chunks_to_symbols_bc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_chunks_to_symbols_bc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_chunks_to_symbols_bc_sptr
        __init__(self,  p) -> digital_chunks_to_symbols_bc_sptr
        """
        this = _digital_swig.new_digital_chunks_to_symbols_bc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_chunks_to_symbols_bc_sptr
    __del__ = lambda self : None;
    def D(self):
        """D(self) -> int"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_D(self)

    def symbol_table(self):
        """symbol_table(self) -> gr_complex_vector"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_symbol_table(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_bc_sptr_check_topology(self, *args, **kwargs)

digital_chunks_to_symbols_bc_sptr_swigregister = _digital_swig.digital_chunks_to_symbols_bc_sptr_swigregister
digital_chunks_to_symbols_bc_sptr_swigregister(digital_chunks_to_symbols_bc_sptr)

digital_chunks_to_symbols_bc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def chunks_to_symbols_bc(*args, **kwargs):
  """
    chunks_to_symbols_bc(gr_complex_vector symbol_table, int D = 1) -> digital_chunks_to_symbols_bc_sptr

    Map a stream of symbol indexes (unpacked bytes or shorts) to stream of float or complex constellation points in D dimensions (D = 1 by default)

    input: stream of unsigned char; output: stream of gr_complex.

    out[n D + k] = symbol_table[in[n] D + k], k=0,1,...,D-1

    The combination of gr_packed_to_unpacked_XX followed by gr_chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.
    """
  return _digital_swig.chunks_to_symbols_bc(*args, **kwargs)
class digital_chunks_to_symbols_sf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_chunks_to_symbols_sf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_chunks_to_symbols_sf_sptr
        __init__(self,  p) -> digital_chunks_to_symbols_sf_sptr
        """
        this = _digital_swig.new_digital_chunks_to_symbols_sf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_chunks_to_symbols_sf_sptr
    __del__ = lambda self : None;
    def D(self):
        """D(self) -> int"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_D(self)

    def symbol_table(self):
        """symbol_table(self) -> __dummy_4__"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_symbol_table(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_sf_sptr_check_topology(self, *args, **kwargs)

digital_chunks_to_symbols_sf_sptr_swigregister = _digital_swig.digital_chunks_to_symbols_sf_sptr_swigregister
digital_chunks_to_symbols_sf_sptr_swigregister(digital_chunks_to_symbols_sf_sptr)

digital_chunks_to_symbols_sf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def chunks_to_symbols_sf(*args, **kwargs):
  """
    chunks_to_symbols_sf(__dummy_4__ symbol_table, int D = 1) -> digital_chunks_to_symbols_sf_sptr

    Map a stream of symbol indexes (unpacked bytes or shorts) to stream of float or complex constellation points in D dimensions (D = 1 by default)

    input: stream of short; output: stream of float.

    out[n D + k] = symbol_table[in[n] D + k], k=0,1,...,D-1

    The combination of gr_packed_to_unpacked_XX followed by gr_chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.
    """
  return _digital_swig.chunks_to_symbols_sf(*args, **kwargs)
class digital_chunks_to_symbols_sc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_chunks_to_symbols_sc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_chunks_to_symbols_sc_sptr
        __init__(self,  p) -> digital_chunks_to_symbols_sc_sptr
        """
        this = _digital_swig.new_digital_chunks_to_symbols_sc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_chunks_to_symbols_sc_sptr
    __del__ = lambda self : None;
    def D(self):
        """D(self) -> int"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_D(self)

    def symbol_table(self):
        """symbol_table(self) -> gr_complex_vector"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_symbol_table(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_sc_sptr_check_topology(self, *args, **kwargs)

digital_chunks_to_symbols_sc_sptr_swigregister = _digital_swig.digital_chunks_to_symbols_sc_sptr_swigregister
digital_chunks_to_symbols_sc_sptr_swigregister(digital_chunks_to_symbols_sc_sptr)

digital_chunks_to_symbols_sc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def chunks_to_symbols_sc(*args, **kwargs):
  """
    chunks_to_symbols_sc(gr_complex_vector symbol_table, int D = 1) -> digital_chunks_to_symbols_sc_sptr

    Map a stream of symbol indexes (unpacked bytes or shorts) to stream of float or complex constellation points in D dimensions (D = 1 by default)

    input: stream of short; output: stream of gr_complex.

    out[n D + k] = symbol_table[in[n] D + k], k=0,1,...,D-1

    The combination of gr_packed_to_unpacked_XX followed by gr_chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.
    """
  return _digital_swig.chunks_to_symbols_sc(*args, **kwargs)
class digital_chunks_to_symbols_if_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_chunks_to_symbols_if)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_chunks_to_symbols_if_sptr
        __init__(self,  p) -> digital_chunks_to_symbols_if_sptr
        """
        this = _digital_swig.new_digital_chunks_to_symbols_if_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_chunks_to_symbols_if_sptr
    __del__ = lambda self : None;
    def D(self):
        """D(self) -> int"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_D(self)

    def symbol_table(self):
        """symbol_table(self) -> __dummy_4__"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_symbol_table(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_if_sptr_check_topology(self, *args, **kwargs)

digital_chunks_to_symbols_if_sptr_swigregister = _digital_swig.digital_chunks_to_symbols_if_sptr_swigregister
digital_chunks_to_symbols_if_sptr_swigregister(digital_chunks_to_symbols_if_sptr)

digital_chunks_to_symbols_if_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def chunks_to_symbols_if(*args, **kwargs):
  """
    chunks_to_symbols_if(__dummy_4__ symbol_table, int D = 1) -> digital_chunks_to_symbols_if_sptr

    Map a stream of symbol indexes (unpacked bytes or shorts) to stream of float or complex constellation points in D dimensions (D = 1 by default)

    input: stream of int; output: stream of float.

    out[n D + k] = symbol_table[in[n] D + k], k=0,1,...,D-1

    The combination of gr_packed_to_unpacked_XX followed by gr_chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.
    """
  return _digital_swig.chunks_to_symbols_if(*args, **kwargs)
class digital_chunks_to_symbols_ic_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_chunks_to_symbols_ic)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_chunks_to_symbols_ic_sptr
        __init__(self,  p) -> digital_chunks_to_symbols_ic_sptr
        """
        this = _digital_swig.new_digital_chunks_to_symbols_ic_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_chunks_to_symbols_ic_sptr
    __del__ = lambda self : None;
    def D(self):
        """D(self) -> int"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_D(self)

    def symbol_table(self):
        """symbol_table(self) -> gr_complex_vector"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_symbol_table(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_chunks_to_symbols_ic_sptr_check_topology(self, *args, **kwargs)

digital_chunks_to_symbols_ic_sptr_swigregister = _digital_swig.digital_chunks_to_symbols_ic_sptr_swigregister
digital_chunks_to_symbols_ic_sptr_swigregister(digital_chunks_to_symbols_ic_sptr)

digital_chunks_to_symbols_ic_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def chunks_to_symbols_ic(*args, **kwargs):
  """
    chunks_to_symbols_ic(gr_complex_vector symbol_table, int D = 1) -> digital_chunks_to_symbols_ic_sptr

    Map a stream of symbol indexes (unpacked bytes or shorts) to stream of float or complex constellation points in D dimensions (D = 1 by default)

    input: stream of int; output: stream of gr_complex.

    out[n D + k] = symbol_table[in[n] D + k], k=0,1,...,D-1

    The combination of gr_packed_to_unpacked_XX followed by gr_chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.
    """
  return _digital_swig.chunks_to_symbols_ic(*args, **kwargs)
class digital_additive_scrambler_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_additive_scrambler_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_additive_scrambler_bb_sptr
        __init__(self,  p) -> digital_additive_scrambler_bb_sptr
        """
        this = _digital_swig.new_digital_additive_scrambler_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_additive_scrambler_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_additive_scrambler_bb_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_additive_scrambler_bb_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_additive_scrambler_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_additive_scrambler_bb_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_additive_scrambler_bb_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_additive_scrambler_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_additive_scrambler_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_additive_scrambler_bb_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_additive_scrambler_bb_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_additive_scrambler_bb_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_additive_scrambler_bb_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_additive_scrambler_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_additive_scrambler_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_additive_scrambler_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_additive_scrambler_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_additive_scrambler_bb_sptr_check_topology(self, *args, **kwargs)

digital_additive_scrambler_bb_sptr_swigregister = _digital_swig.digital_additive_scrambler_bb_sptr_swigregister
digital_additive_scrambler_bb_sptr_swigregister(digital_additive_scrambler_bb_sptr)

digital_additive_scrambler_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def additive_scrambler_bb(*args, **kwargs):
  """
    additive_scrambler_bb(int mask, int seed, int len, int count = 0) -> digital_additive_scrambler_bb_sptr

    Scramble an input stream using an LFSR. This block works on the LSB only of the input data stream, i.e., on an "unpacked binary" stream, and produces the same format on its output.


    The scrambler works by XORing the incoming bit stream by the output of the LFSR. Optionally, after 'count' bits have been processed, the shift register is reset to the seed value. This allows processing fixed length vectors of samples.

    Args:
        mask : Polynomial mask for LFSR
        seed : Initial shift register contents
        len : Shift register length
        count : Number of bits after which shift register is reset, 0=never
    """
  return _digital_swig.additive_scrambler_bb(*args, **kwargs)
class digital_bytes_to_syms_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_bytes_to_syms)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_bytes_to_syms_sptr
        __init__(self,  p) -> digital_bytes_to_syms_sptr
        """
        this = _digital_swig.new_digital_bytes_to_syms_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_bytes_to_syms_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_bytes_to_syms_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_bytes_to_syms_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_bytes_to_syms_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_bytes_to_syms_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_bytes_to_syms_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_bytes_to_syms_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_bytes_to_syms_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_bytes_to_syms_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_bytes_to_syms_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_bytes_to_syms_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_bytes_to_syms_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_bytes_to_syms_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_bytes_to_syms_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_bytes_to_syms_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_bytes_to_syms_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_bytes_to_syms_sptr_check_topology(self, *args, **kwargs)

digital_bytes_to_syms_sptr_swigregister = _digital_swig.digital_bytes_to_syms_sptr_swigregister
digital_bytes_to_syms_sptr_swigregister(digital_bytes_to_syms_sptr)

digital_bytes_to_syms_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def bytes_to_syms():
  """
    bytes_to_syms() -> digital_bytes_to_syms_sptr

    Convert stream of bytes to stream of +/- 1 symbols

    input: stream of bytes; output: stream of float.

    This block is deprecated.

    The combination of gr_packed_to_unpacked_bb followed by gr_chunks_to_symbols_bf or gr_chunks_to_symbols_bc handles the general case of mapping from a stream of bytes into arbitrary float or complex symbols.
    """
  return _digital_swig.bytes_to_syms()
class digital_binary_slicer_fb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_binary_slicer_fb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_binary_slicer_fb_sptr
        __init__(self,  p) -> digital_binary_slicer_fb_sptr
        """
        this = _digital_swig.new_digital_binary_slicer_fb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_binary_slicer_fb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_binary_slicer_fb_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_binary_slicer_fb_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_binary_slicer_fb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_binary_slicer_fb_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_binary_slicer_fb_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_binary_slicer_fb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_binary_slicer_fb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_binary_slicer_fb_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_binary_slicer_fb_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_binary_slicer_fb_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_binary_slicer_fb_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_binary_slicer_fb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_binary_slicer_fb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_binary_slicer_fb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_binary_slicer_fb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_binary_slicer_fb_sptr_check_topology(self, *args, **kwargs)

digital_binary_slicer_fb_sptr_swigregister = _digital_swig.digital_binary_slicer_fb_sptr_swigregister
digital_binary_slicer_fb_sptr_swigregister(digital_binary_slicer_fb_sptr)

digital_binary_slicer_fb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def binary_slicer_fb():
  """
    binary_slicer_fb() -> digital_binary_slicer_fb_sptr

    slice float binary symbol outputting 1 bit output

    x < 0 --> 0 x >= 0 --> 1
    """
  return _digital_swig.binary_slicer_fb()
class digital_clock_recovery_mm_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_clock_recovery_mm_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_clock_recovery_mm_cc_sptr
        __init__(self,  p) -> digital_clock_recovery_mm_cc_sptr
        """
        this = _digital_swig.new_digital_clock_recovery_mm_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_clock_recovery_mm_cc_sptr
    __del__ = lambda self : None;
    def mu(self):
        """mu(self) -> float"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_mu(self)

    def omega(self):
        """omega(self) -> float"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_omega(self)

    def gain_mu(self):
        """gain_mu(self) -> float"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_gain_mu(self)

    def gain_omega(self):
        """gain_omega(self) -> float"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_gain_omega(self)

    def set_gain_mu(self, *args, **kwargs):
        """set_gain_mu(self, float gain_mu)"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_set_gain_mu(self, *args, **kwargs)

    def set_gain_omega(self, *args, **kwargs):
        """set_gain_omega(self, float gain_omega)"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_set_gain_omega(self, *args, **kwargs)

    def set_mu(self, *args, **kwargs):
        """set_mu(self, float omega)"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_set_mu(self, *args, **kwargs)

    def set_omega(self, *args, **kwargs):
        """set_omega(self, float omega)"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_set_omega(self, *args, **kwargs)

    def set_verbose(self, *args, **kwargs):
        """set_verbose(self, bool verbose)"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_set_verbose(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_clock_recovery_mm_cc_sptr_check_topology(self, *args, **kwargs)

digital_clock_recovery_mm_cc_sptr_swigregister = _digital_swig.digital_clock_recovery_mm_cc_sptr_swigregister
digital_clock_recovery_mm_cc_sptr_swigregister(digital_clock_recovery_mm_cc_sptr)

digital_clock_recovery_mm_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def clock_recovery_mm_cc(*args, **kwargs):
  """
    clock_recovery_mm_cc(float omega, float gain_omega, float mu, float gain_mu, 
        float omega_relative_limit) -> digital_clock_recovery_mm_cc_sptr

    Mueller and M?ller (M&M) based clock recovery block with complex input, complex output.

    This implements the Mueller and M?ller (M&M) discrete-time error-tracking synchronizer.

    The complex version here is based on: Modified Mueller and Muller clock recovery circuit Based: G. R. Danesfahani, T.G. Jeans, "Optimisation of modified Mueller
        and Muller algorithm," Electronics Letters, Vol. 31, no. 13, 22 June 1995, pp. 1032 - 1033.
    """
  return _digital_swig.clock_recovery_mm_cc(*args, **kwargs)
class digital_clock_recovery_mm_ff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_clock_recovery_mm_ff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_clock_recovery_mm_ff_sptr
        __init__(self,  p) -> digital_clock_recovery_mm_ff_sptr
        """
        this = _digital_swig.new_digital_clock_recovery_mm_ff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_clock_recovery_mm_ff_sptr
    __del__ = lambda self : None;
    def mu(self):
        """mu(self) -> float"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_mu(self)

    def omega(self):
        """omega(self) -> float"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_omega(self)

    def gain_mu(self):
        """gain_mu(self) -> float"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_gain_mu(self)

    def gain_omega(self):
        """gain_omega(self) -> float"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_gain_omega(self)

    def set_gain_mu(self, *args, **kwargs):
        """set_gain_mu(self, float gain_mu)"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_set_gain_mu(self, *args, **kwargs)

    def set_gain_omega(self, *args, **kwargs):
        """set_gain_omega(self, float gain_omega)"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_set_gain_omega(self, *args, **kwargs)

    def set_mu(self, *args, **kwargs):
        """set_mu(self, float omega)"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_set_mu(self, *args, **kwargs)

    def set_omega(self, *args, **kwargs):
        """set_omega(self, float omega)"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_set_omega(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_clock_recovery_mm_ff_sptr_check_topology(self, *args, **kwargs)

digital_clock_recovery_mm_ff_sptr_swigregister = _digital_swig.digital_clock_recovery_mm_ff_sptr_swigregister
digital_clock_recovery_mm_ff_sptr_swigregister(digital_clock_recovery_mm_ff_sptr)

digital_clock_recovery_mm_ff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def clock_recovery_mm_ff(*args, **kwargs):
  """
    clock_recovery_mm_ff(float omega, float gain_omega, float mu, float gain_mu, 
        float omega_relative_limit = 0.001) -> digital_clock_recovery_mm_ff_sptr

    Mueller and M?ller (M&M) based clock recovery block with float input, float output.

    This implements the Mueller and M?ller (M&M) discrete-time error-tracking synchronizer.

    See "Digital Communication Receivers: Synchronization, Channel
     Estimation and Signal Processing" by Heinrich Meyr, Marc Moeneclaey, & Stefan Fechtel. ISBN 0-471-50275-8.
    """
  return _digital_swig.clock_recovery_mm_ff(*args, **kwargs)
class digital_cma_equalizer_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_cma_equalizer_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_cma_equalizer_cc_sptr
        __init__(self,  p) -> digital_cma_equalizer_cc_sptr
        """
        this = _digital_swig.new_digital_cma_equalizer_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_cma_equalizer_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_cma_equalizer_cc_sptr
    __del__ = lambda self : None;
    def get_gain(self):
        """get_gain(self) -> float"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_get_gain(self)

    def set_gain(self, *args, **kwargs):
        """set_gain(self, float mu)"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_set_gain(self, *args, **kwargs)

    def get_modulus(self):
        """get_modulus(self) -> float"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_get_modulus(self)

    def set_modulus(self, *args, **kwargs):
        """set_modulus(self, float mod)"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_set_modulus(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(self, gr_complex_vector taps)"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_cma_equalizer_cc_sptr_check_topology(self, *args, **kwargs)

digital_cma_equalizer_cc_sptr_swigregister = _digital_swig.digital_cma_equalizer_cc_sptr_swigregister
digital_cma_equalizer_cc_sptr_swigregister(digital_cma_equalizer_cc_sptr)

digital_cma_equalizer_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def cma_equalizer_cc(*args, **kwargs):
  """
    cma_equalizer_cc(int num_taps, float modulus, float mu, int sps) -> digital_cma_equalizer_cc_sptr

    Implements constant modulus adaptive filter on complex stream

    The error value and tap update equations (for p=2) can be found in:

    "D. Godard, "Self-Recovering Equalization and Carrier Tracking in Two-Dimensional Data Communication Systems," IEEE Transactions on
     Communications, Vol. 28, No. 11, pp. 1867 - 1875, 1980."
    """
  return _digital_swig.cma_equalizer_cc(*args, **kwargs)
class gr_complex_vector(object):
    """Proxy of C++ std::vector<(gr_complex)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _digital_swig.gr_complex_vector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _digital_swig.gr_complex_vector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _digital_swig.gr_complex_vector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _digital_swig.gr_complex_vector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _digital_swig.gr_complex_vector_pop(self)

    def __getslice__(self, *args, **kwargs):
        """__getslice__(self, difference_type i, difference_type j) -> __dummy_6__"""
        return _digital_swig.gr_complex_vector___getslice__(self, *args, **kwargs)

    def __setslice__(self, *args, **kwargs):
        """__setslice__(self, difference_type i, difference_type j, __dummy_6__ v = std::vector< std::complex< float >,std::allocator< std::complex< float > > >())"""
        return _digital_swig.gr_complex_vector___setslice__(self, *args, **kwargs)

    def __delslice__(self, *args, **kwargs):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _digital_swig.gr_complex_vector___delslice__(self, *args, **kwargs)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _digital_swig.gr_complex_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> __dummy_6__
        __getitem__(self, difference_type i) -> value_type
        """
        return _digital_swig.gr_complex_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, __dummy_6__ v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _digital_swig.gr_complex_vector___setitem__(self, *args)

    def append(self, *args, **kwargs):
        """append(self, value_type x)"""
        return _digital_swig.gr_complex_vector_append(self, *args, **kwargs)

    def empty(self):
        """empty(self) -> bool"""
        return _digital_swig.gr_complex_vector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _digital_swig.gr_complex_vector_size(self)

    def clear(self):
        """clear(self)"""
        return _digital_swig.gr_complex_vector_clear(self)

    def swap(self, *args, **kwargs):
        """swap(self, gr_complex_vector v)"""
        return _digital_swig.gr_complex_vector_swap(self, *args, **kwargs)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _digital_swig.gr_complex_vector_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _digital_swig.gr_complex_vector_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _digital_swig.gr_complex_vector_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _digital_swig.gr_complex_vector_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _digital_swig.gr_complex_vector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _digital_swig.gr_complex_vector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _digital_swig.gr_complex_vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> gr_complex_vector
        __init__(self, gr_complex_vector arg0) -> gr_complex_vector
        __init__(self, size_type size) -> gr_complex_vector
        __init__(self, size_type size, value_type value) -> gr_complex_vector
        """
        this = _digital_swig.new_gr_complex_vector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args, **kwargs):
        """push_back(self, value_type x)"""
        return _digital_swig.gr_complex_vector_push_back(self, *args, **kwargs)

    def front(self):
        """front(self) -> value_type"""
        return _digital_swig.gr_complex_vector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _digital_swig.gr_complex_vector_back(self)

    def assign(self, *args, **kwargs):
        """assign(self, size_type n, value_type x)"""
        return _digital_swig.gr_complex_vector_assign(self, *args, **kwargs)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _digital_swig.gr_complex_vector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _digital_swig.gr_complex_vector_insert(self, *args)

    def reserve(self, *args, **kwargs):
        """reserve(self, size_type n)"""
        return _digital_swig.gr_complex_vector_reserve(self, *args, **kwargs)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _digital_swig.gr_complex_vector_capacity(self)

    __swig_destroy__ = _digital_swig.delete_gr_complex_vector
    __del__ = lambda self : None;
gr_complex_vector_swigregister = _digital_swig.gr_complex_vector_swigregister
gr_complex_vector_swigregister(gr_complex_vector)

class unsigned_int_vector(object):
    """Proxy of C++ std::vector<(unsigned int)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _digital_swig.unsigned_int_vector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _digital_swig.unsigned_int_vector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _digital_swig.unsigned_int_vector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _digital_swig.unsigned_int_vector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _digital_swig.unsigned_int_vector_pop(self)

    def __getslice__(self, *args, **kwargs):
        """__getslice__(self, difference_type i, difference_type j) -> unsigned_int_vector"""
        return _digital_swig.unsigned_int_vector___getslice__(self, *args, **kwargs)

    def __setslice__(self, *args, **kwargs):
        """__setslice__(self, difference_type i, difference_type j, unsigned_int_vector v = std::vector< unsigned int,std::allocator< unsigned int > >())"""
        return _digital_swig.unsigned_int_vector___setslice__(self, *args, **kwargs)

    def __delslice__(self, *args, **kwargs):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _digital_swig.unsigned_int_vector___delslice__(self, *args, **kwargs)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _digital_swig.unsigned_int_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> unsigned_int_vector
        __getitem__(self, difference_type i) -> value_type
        """
        return _digital_swig.unsigned_int_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, unsigned_int_vector v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _digital_swig.unsigned_int_vector___setitem__(self, *args)

    def append(self, *args, **kwargs):
        """append(self, value_type x)"""
        return _digital_swig.unsigned_int_vector_append(self, *args, **kwargs)

    def empty(self):
        """empty(self) -> bool"""
        return _digital_swig.unsigned_int_vector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _digital_swig.unsigned_int_vector_size(self)

    def clear(self):
        """clear(self)"""
        return _digital_swig.unsigned_int_vector_clear(self)

    def swap(self, *args, **kwargs):
        """swap(self, unsigned_int_vector v)"""
        return _digital_swig.unsigned_int_vector_swap(self, *args, **kwargs)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _digital_swig.unsigned_int_vector_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _digital_swig.unsigned_int_vector_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _digital_swig.unsigned_int_vector_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _digital_swig.unsigned_int_vector_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _digital_swig.unsigned_int_vector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _digital_swig.unsigned_int_vector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _digital_swig.unsigned_int_vector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> unsigned_int_vector
        __init__(self, unsigned_int_vector arg0) -> unsigned_int_vector
        __init__(self, size_type size) -> unsigned_int_vector
        __init__(self, size_type size, value_type value) -> unsigned_int_vector
        """
        this = _digital_swig.new_unsigned_int_vector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args, **kwargs):
        """push_back(self, value_type x)"""
        return _digital_swig.unsigned_int_vector_push_back(self, *args, **kwargs)

    def front(self):
        """front(self) -> value_type"""
        return _digital_swig.unsigned_int_vector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _digital_swig.unsigned_int_vector_back(self)

    def assign(self, *args, **kwargs):
        """assign(self, size_type n, value_type x)"""
        return _digital_swig.unsigned_int_vector_assign(self, *args, **kwargs)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _digital_swig.unsigned_int_vector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _digital_swig.unsigned_int_vector_insert(self, *args)

    def reserve(self, *args, **kwargs):
        """reserve(self, size_type n)"""
        return _digital_swig.unsigned_int_vector_reserve(self, *args, **kwargs)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _digital_swig.unsigned_int_vector_capacity(self)

    __swig_destroy__ = _digital_swig.delete_unsigned_int_vector
    __del__ = lambda self : None;
unsigned_int_vector_swigregister = _digital_swig.unsigned_int_vector_swigregister
unsigned_int_vector_swigregister(unsigned_int_vector)

TRELLIS_EUCLIDEAN = _digital_swig.TRELLIS_EUCLIDEAN
TRELLIS_HARD_SYMBOL = _digital_swig.TRELLIS_HARD_SYMBOL
TRELLIS_HARD_BIT = _digital_swig.TRELLIS_HARD_BIT
class digital_constellation_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_sptr
        __init__(self, digital_constellation p) -> digital_constellation_sptr
        """
        this = _digital_swig.new_digital_constellation_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self) -> digital_constellation"""
        return _digital_swig.digital_constellation_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_sptr
    __del__ = lambda self : None;
    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.
        """
        return _digital_swig.digital_constellation_sptr_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.digital_constellation_sptr_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.
        """
        return _digital_swig.digital_constellation_sptr_v_points(self)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.digital_constellation_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.digital_constellation_sptr_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(self, unsigned int value) -> gr_complex_vector"""
        return _digital_swig.digital_constellation_sptr_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """bits_per_symbol(self) -> unsigned int"""
        return _digital_swig.digital_constellation_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(self) -> unsigned int"""
        return _digital_swig.digital_constellation_sptr_arity(self)

    def base(self):
        """base(self) -> digital_constellation_sptr"""
        return _digital_swig.digital_constellation_sptr_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.digital_constellation_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.digital_constellation_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.digital_constellation_sptr_dimensionality(self)

digital_constellation_sptr_swigregister = _digital_swig.digital_constellation_sptr_swigregister
digital_constellation_sptr_swigregister(digital_constellation_sptr)

class digital_constellation(object):
    """
    An abstracted constellation object

    The constellation objects hold the necessary information to pass around constellation information for modulators and demodulators. These objects contain the mapping between the bits and the constellation points used to represent them as well as methods for slicing the symbol space. Various implementations are possible for efficiency and ease of use.

    Standard constellations (BPSK, QPSK, QAM, etc) can be inherited from this class and overloaded to perform optimized slicing and constellation mappings.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.
        """
        return _digital_swig.digital_constellation_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.digital_constellation_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.
        """
        return _digital_swig.digital_constellation_v_points(self)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.digital_constellation_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.digital_constellation_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(self, unsigned int value) -> gr_complex_vector"""
        return _digital_swig.digital_constellation_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """bits_per_symbol(self) -> unsigned int"""
        return _digital_swig.digital_constellation_bits_per_symbol(self)

    def arity(self):
        """arity(self) -> unsigned int"""
        return _digital_swig.digital_constellation_arity(self)

    def base(self):
        """base(self) -> digital_constellation_sptr"""
        return _digital_swig.digital_constellation_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.digital_constellation_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.digital_constellation_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.digital_constellation_dimensionality(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation
    __del__ = lambda self : None;
digital_constellation_swigregister = _digital_swig.digital_constellation_swigregister
digital_constellation_swigregister(digital_constellation)

class digital_constellation_calcdist_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_calcdist)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_calcdist_sptr
        __init__(self,  p) -> digital_constellation_calcdist_sptr
        """
        this = _digital_swig.new_digital_constellation_calcdist_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_calcdist_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_calcdist_sptr
    __del__ = lambda self : None;
    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.digital_constellation_calcdist_sptr_decision_maker(self, *args, **kwargs)

    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.
        """
        return _digital_swig.digital_constellation_calcdist_sptr_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.digital_constellation_calcdist_sptr_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.
        """
        return _digital_swig.digital_constellation_calcdist_sptr_v_points(self)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.digital_constellation_calcdist_sptr_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(self, unsigned int value) -> gr_complex_vector"""
        return _digital_swig.digital_constellation_calcdist_sptr_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """bits_per_symbol(self) -> unsigned int"""
        return _digital_swig.digital_constellation_calcdist_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(self) -> unsigned int"""
        return _digital_swig.digital_constellation_calcdist_sptr_arity(self)

    def base(self):
        """base(self) -> digital_constellation_sptr"""
        return _digital_swig.digital_constellation_calcdist_sptr_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_calcdist_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_calcdist_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.digital_constellation_calcdist_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.digital_constellation_calcdist_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.digital_constellation_calcdist_sptr_dimensionality(self)

digital_constellation_calcdist_sptr_swigregister = _digital_swig.digital_constellation_calcdist_sptr_swigregister
digital_constellation_calcdist_sptr_swigregister(digital_constellation_calcdist_sptr)


def constellation_calcdist(*args, **kwargs):
  """
    constellation_calcdist(gr_complex_vector constellation, unsigned_int_vector pre_diff_code, 
        unsigned int rotational_symmetry, 
        unsigned int dimensionality) -> digital_constellation_calcdist_sptr

    Calculate Euclidian distance for any constellation

    Constellation which calculates the distance to each point in the constellation for decision making. Inefficient for large constellations.
    """
  return _digital_swig.constellation_calcdist(*args, **kwargs)
class digital_constellation_sector(digital_constellation):
    """
    Sectorized digital constellation

    Constellation space is divided into sectors. Each sector is associated with the nearest constellation point.

    digital_constellation_sector
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _digital_swig.delete_digital_constellation_sector
    __del__ = lambda self : None;
digital_constellation_sector_swigregister = _digital_swig.digital_constellation_sector_swigregister
digital_constellation_sector_swigregister(digital_constellation_sector)

class digital_constellation_rect_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_rect)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_rect_sptr
        __init__(self,  p) -> digital_constellation_rect_sptr
        """
        this = _digital_swig.new_digital_constellation_rect_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_rect_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_rect_sptr
    __del__ = lambda self : None;
    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.
        """
        return _digital_swig.digital_constellation_rect_sptr_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.digital_constellation_rect_sptr_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.
        """
        return _digital_swig.digital_constellation_rect_sptr_v_points(self)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.digital_constellation_rect_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.digital_constellation_rect_sptr_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(self, unsigned int value) -> gr_complex_vector"""
        return _digital_swig.digital_constellation_rect_sptr_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """bits_per_symbol(self) -> unsigned int"""
        return _digital_swig.digital_constellation_rect_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(self) -> unsigned int"""
        return _digital_swig.digital_constellation_rect_sptr_arity(self)

    def base(self):
        """base(self) -> digital_constellation_sptr"""
        return _digital_swig.digital_constellation_rect_sptr_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_rect_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_rect_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.digital_constellation_rect_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.digital_constellation_rect_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.digital_constellation_rect_sptr_dimensionality(self)

digital_constellation_rect_sptr_swigregister = _digital_swig.digital_constellation_rect_sptr_swigregister
digital_constellation_rect_sptr_swigregister(digital_constellation_rect_sptr)


def constellation_rect(*args, **kwargs):
  """
    constellation_rect(gr_complex_vector constellation, unsigned_int_vector pre_diff_code, 
        unsigned int rotational_symmetry, 
        unsigned int real_sectors, unsigned int imag_sectors, 
        float width_real_sectors, float width_imag_sectors) -> digital_constellation_rect_sptr
    """
  return _digital_swig.constellation_rect(*args, **kwargs)
class digital_constellation_psk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_psk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_psk_sptr
        __init__(self,  p) -> digital_constellation_psk_sptr
        """
        this = _digital_swig.new_digital_constellation_psk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_psk_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_psk_sptr
    __del__ = lambda self : None;
    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.
        """
        return _digital_swig.digital_constellation_psk_sptr_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.digital_constellation_psk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.
        """
        return _digital_swig.digital_constellation_psk_sptr_v_points(self)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.digital_constellation_psk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.digital_constellation_psk_sptr_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(self, unsigned int value) -> gr_complex_vector"""
        return _digital_swig.digital_constellation_psk_sptr_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """bits_per_symbol(self) -> unsigned int"""
        return _digital_swig.digital_constellation_psk_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(self) -> unsigned int"""
        return _digital_swig.digital_constellation_psk_sptr_arity(self)

    def base(self):
        """base(self) -> digital_constellation_sptr"""
        return _digital_swig.digital_constellation_psk_sptr_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_psk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_psk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.digital_constellation_psk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.digital_constellation_psk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.digital_constellation_psk_sptr_dimensionality(self)

digital_constellation_psk_sptr_swigregister = _digital_swig.digital_constellation_psk_sptr_swigregister
digital_constellation_psk_sptr_swigregister(digital_constellation_psk_sptr)


def constellation_psk(*args, **kwargs):
  """
    constellation_psk(gr_complex_vector constellation, unsigned_int_vector pre_diff_code, 
        unsigned int n_sectors) -> digital_constellation_psk_sptr

    digital_constellation_psk

    Constellation space is divided into pie slices sectors.

    Each slice is associated with the nearest constellation point.

    Works well for PSK but nothing else.

    Assumes that there is a constellation point at 1.x
    """
  return _digital_swig.constellation_psk(*args, **kwargs)
class digital_constellation_bpsk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_bpsk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_bpsk_sptr
        __init__(self,  p) -> digital_constellation_bpsk_sptr
        """
        this = _digital_swig.new_digital_constellation_bpsk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_bpsk_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_bpsk_sptr
    __del__ = lambda self : None;
    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.
        """
        return _digital_swig.digital_constellation_bpsk_sptr_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.digital_constellation_bpsk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.
        """
        return _digital_swig.digital_constellation_bpsk_sptr_v_points(self)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.digital_constellation_bpsk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.digital_constellation_bpsk_sptr_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(self, unsigned int value) -> gr_complex_vector"""
        return _digital_swig.digital_constellation_bpsk_sptr_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """bits_per_symbol(self) -> unsigned int"""
        return _digital_swig.digital_constellation_bpsk_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(self) -> unsigned int"""
        return _digital_swig.digital_constellation_bpsk_sptr_arity(self)

    def base(self):
        """base(self) -> digital_constellation_sptr"""
        return _digital_swig.digital_constellation_bpsk_sptr_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_bpsk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_bpsk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.digital_constellation_bpsk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.digital_constellation_bpsk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.digital_constellation_bpsk_sptr_dimensionality(self)

digital_constellation_bpsk_sptr_swigregister = _digital_swig.digital_constellation_bpsk_sptr_swigregister
digital_constellation_bpsk_sptr_swigregister(digital_constellation_bpsk_sptr)


def constellation_bpsk():
  """
    constellation_bpsk() -> digital_constellation_bpsk_sptr

    Digital constellation for BPSK.
    """
  return _digital_swig.constellation_bpsk()
class digital_constellation_qpsk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_qpsk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_qpsk_sptr
        __init__(self,  p) -> digital_constellation_qpsk_sptr
        """
        this = _digital_swig.new_digital_constellation_qpsk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_qpsk_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_qpsk_sptr
    __del__ = lambda self : None;
    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.
        """
        return _digital_swig.digital_constellation_qpsk_sptr_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.digital_constellation_qpsk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.
        """
        return _digital_swig.digital_constellation_qpsk_sptr_v_points(self)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.digital_constellation_qpsk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.digital_constellation_qpsk_sptr_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(self, unsigned int value) -> gr_complex_vector"""
        return _digital_swig.digital_constellation_qpsk_sptr_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """bits_per_symbol(self) -> unsigned int"""
        return _digital_swig.digital_constellation_qpsk_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(self) -> unsigned int"""
        return _digital_swig.digital_constellation_qpsk_sptr_arity(self)

    def base(self):
        """base(self) -> digital_constellation_sptr"""
        return _digital_swig.digital_constellation_qpsk_sptr_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_qpsk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_qpsk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.digital_constellation_qpsk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.digital_constellation_qpsk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.digital_constellation_qpsk_sptr_dimensionality(self)

digital_constellation_qpsk_sptr_swigregister = _digital_swig.digital_constellation_qpsk_sptr_swigregister
digital_constellation_qpsk_sptr_swigregister(digital_constellation_qpsk_sptr)


def constellation_qpsk():
  """
    constellation_qpsk() -> digital_constellation_qpsk_sptr

    Digital constellation for QPSK.
    """
  return _digital_swig.constellation_qpsk()
class digital_constellation_dqpsk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_dqpsk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_dqpsk_sptr
        __init__(self,  p) -> digital_constellation_dqpsk_sptr
        """
        this = _digital_swig.new_digital_constellation_dqpsk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_dqpsk_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_dqpsk_sptr
    __del__ = lambda self : None;
    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_v_points(self)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(self, unsigned int value) -> gr_complex_vector"""
        return _digital_swig.digital_constellation_dqpsk_sptr_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """bits_per_symbol(self) -> unsigned int"""
        return _digital_swig.digital_constellation_dqpsk_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(self) -> unsigned int"""
        return _digital_swig.digital_constellation_dqpsk_sptr_arity(self)

    def base(self):
        """base(self) -> digital_constellation_sptr"""
        return _digital_swig.digital_constellation_dqpsk_sptr_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.digital_constellation_dqpsk_sptr_dimensionality(self)

digital_constellation_dqpsk_sptr_swigregister = _digital_swig.digital_constellation_dqpsk_sptr_swigregister
digital_constellation_dqpsk_sptr_swigregister(digital_constellation_dqpsk_sptr)


def constellation_dqpsk():
  """
    constellation_dqpsk() -> digital_constellation_dqpsk_sptr

    Digital constellation for DQPSK.
    """
  return _digital_swig.constellation_dqpsk()
class digital_constellation_8psk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_8psk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_8psk_sptr
        __init__(self,  p) -> digital_constellation_8psk_sptr
        """
        this = _digital_swig.new_digital_constellation_8psk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_8psk_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_8psk_sptr
    __del__ = lambda self : None;
    def points(self):
        """
        points(self) -> gr_complex_vector

        Returns the set of points in this constellation.
        """
        return _digital_swig.digital_constellation_8psk_sptr_points(self)

    def s_points(self):
        """
        s_points(self) -> gr_complex_vector

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.digital_constellation_8psk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(self) -> std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)>

        Returns a vector of vectors of points.
        """
        return _digital_swig.digital_constellation_8psk_sptr_v_points(self)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(self, gr_complex sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.digital_constellation_8psk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(self, gr_complex_vector sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.digital_constellation_8psk_sptr_decision_maker_v(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(self, unsigned int value) -> gr_complex_vector"""
        return _digital_swig.digital_constellation_8psk_sptr_map_to_points_v(self, *args, **kwargs)

    def bits_per_symbol(self):
        """bits_per_symbol(self) -> unsigned int"""
        return _digital_swig.digital_constellation_8psk_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(self) -> unsigned int"""
        return _digital_swig.digital_constellation_8psk_sptr_arity(self)

    def base(self):
        """base(self) -> digital_constellation_sptr"""
        return _digital_swig.digital_constellation_8psk_sptr_base(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_8psk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.digital_constellation_8psk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(self) -> unsigned_int_vector

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.digital_constellation_8psk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.digital_constellation_8psk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.digital_constellation_8psk_sptr_dimensionality(self)

digital_constellation_8psk_sptr_swigregister = _digital_swig.digital_constellation_8psk_sptr_swigregister
digital_constellation_8psk_sptr_swigregister(digital_constellation_8psk_sptr)


def constellation_8psk():
  """
    constellation_8psk() -> digital_constellation_8psk_sptr

    Digital constellation for 8PSK.
    """
  return _digital_swig.constellation_8psk()
digital_constellation_calcdist_sptr.__repr__ = lambda self: '<constellation calcdist (m=%s)>' % str(len(self.points()))
digital_constellation_rect_sptr.__repr__ = lambda self: '<constellation rect (m=%s)>' % str(len(self.points()))
digital_constellation_psk_sptr.__repr__ = lambda self: '<constellation psk (m=%s)>' % str(len(self.points()))
digital_constellation_bpsk_sptr.__repr__ = lambda self: '<constellation bpsk>'
digital_constellation_qpsk_sptr.__repr__ = lambda self: '<constellation qpsk>'
digital_constellation_dqpsk_sptr.__repr__ = lambda self: '<constellation dqpsk>'
digital_constellation_8psk_sptr.__repr__ = lambda self: '<constellation 8psk>'
  

class digital_constellation_decoder_cb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_decoder_cb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_decoder_cb_sptr
        __init__(self,  p) -> digital_constellation_decoder_cb_sptr
        """
        this = _digital_swig.new_digital_constellation_decoder_cb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_decoder_cb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_decoder_cb_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_constellation_decoder_cb_sptr_check_topology(self, *args, **kwargs)

digital_constellation_decoder_cb_sptr_swigregister = _digital_swig.digital_constellation_decoder_cb_sptr_swigregister
digital_constellation_decoder_cb_sptr_swigregister(digital_constellation_decoder_cb_sptr)

digital_constellation_decoder_cb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def constellation_decoder_cb(*args, **kwargs):
  """
    constellation_decoder_cb(digital_constellation_sptr constellation) -> digital_constellation_decoder_cb_sptr

    Constellation Decoder.
    """
  return _digital_swig.constellation_decoder_cb(*args, **kwargs)
class digital_constellation_receiver_cb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_constellation_receiver_cb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_constellation_receiver_cb_sptr
        __init__(self,  p) -> digital_constellation_receiver_cb_sptr
        """
        this = _digital_swig.new_digital_constellation_receiver_cb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_constellation_receiver_cb_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_check_topology(self, *args, **kwargs)

    def update_gains(self):
        """update_gains(self)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_update_gains(self)

    def advance_loop(self, *args, **kwargs):
        """advance_loop(self, float error)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_advance_loop(self, *args, **kwargs)

    def phase_wrap(self):
        """phase_wrap(self)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_phase_wrap(self)

    def frequency_limit(self):
        """frequency_limit(self)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_frequency_limit(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """set_loop_bandwidth(self, float bw)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """set_damping_factor(self, float df)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """set_alpha(self, float alpha)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """set_beta(self, float beta)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_set_beta(self, *args, **kwargs)

    def set_frequency(self, *args, **kwargs):
        """set_frequency(self, float freq)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_set_frequency(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """set_phase(self, float phase)"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_set_phase(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """get_loop_bandwidth(self) -> float"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """get_damping_factor(self) -> float"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_get_damping_factor(self)

    def get_alpha(self):
        """get_alpha(self) -> float"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_get_alpha(self)

    def get_beta(self):
        """get_beta(self) -> float"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_get_beta(self)

    def get_frequency(self):
        """get_frequency(self) -> float"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_get_frequency(self)

    def get_phase(self):
        """get_phase(self) -> float"""
        return _digital_swig.digital_constellation_receiver_cb_sptr_get_phase(self)

digital_constellation_receiver_cb_sptr_swigregister = _digital_swig.digital_constellation_receiver_cb_sptr_swigregister
digital_constellation_receiver_cb_sptr_swigregister(digital_constellation_receiver_cb_sptr)

digital_constellation_receiver_cb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def constellation_receiver_cb(*args, **kwargs):
  """
    constellation_receiver_cb(digital_constellation_sptr constellation, float loop_bw, 
        float fmin, float fmax) -> digital_constellation_receiver_cb_sptr

    This block takes care of receiving generic modulated signals through phase, frequency, and symbol synchronization.

    This block takes care of receiving generic modulated signals through phase, frequency, and symbol synchronization. It performs carrier frequency and phase locking as well as symbol timing recovery.

    The phase and frequency synchronization are based on a Costas loop that finds the error of the incoming signal point compared to its nearest constellation point. The frequency and phase of the NCO are updated according to this error.

    The symbol synchronization is done using a modified Mueller and Muller circuit from the paper:

    "G. R. Danesfahani, T.G. Jeans, "Optimisation of modified Mueller and Muller algorithm," Electronics Letters, Vol. 31, no. 13, 22
     June 1995, pp. 1032 - 1033."

    This circuit interpolates the downconverted sample (using the NCO developed by the Costas loop) every mu samples, then it finds the sampling error based on this and the past symbols and the decision made on the samples. Like the phase error detector, there are optimized decision algorithms for BPSK and QPKS, but 8PSK uses another brute force computation against all possible symbols. The modifications to the M&M used here reduce self-noise.
    """
  return _digital_swig.constellation_receiver_cb(*args, **kwargs)
class digital_correlate_access_code_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_correlate_access_code_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_correlate_access_code_bb_sptr
        __init__(self,  p) -> digital_correlate_access_code_bb_sptr
        """
        this = _digital_swig.new_digital_correlate_access_code_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_correlate_access_code_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_correlate_access_code_bb_sptr
    __del__ = lambda self : None;
    def set_access_code(self, *args, **kwargs):
        """set_access_code(self, string access_code) -> bool"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_set_access_code(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_correlate_access_code_bb_sptr_check_topology(self, *args, **kwargs)

digital_correlate_access_code_bb_sptr_swigregister = _digital_swig.digital_correlate_access_code_bb_sptr_swigregister
digital_correlate_access_code_bb_sptr_swigregister(digital_correlate_access_code_bb_sptr)

digital_correlate_access_code_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def correlate_access_code_bb(*args, **kwargs):
  """
    correlate_access_code_bb(string access_code, int threshold) -> digital_correlate_access_code_bb_sptr

    Examine input for specified access code, one bit at a time.

    input: stream of bits, 1 bit per input byte (data in LSB) output: stream of bits, 2 bits per output byte (data in LSB, flag in next higher bit)

    Each output byte contains two valid bits, the data bit, and the flag bit. The LSB (bit 0) is the data bit, and is the original input data, delayed 64 bits. Bit 1 is the flag bit and is 1 if the corresponding data bit is the first data bit following the access code. Otherwise the flag bit is 0.
    """
  return _digital_swig.correlate_access_code_bb(*args, **kwargs)
class digital_correlate_access_code_tag_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_correlate_access_code_tag_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_correlate_access_code_tag_bb_sptr
        __init__(self,  p) -> digital_correlate_access_code_tag_bb_sptr
        """
        this = _digital_swig.new_digital_correlate_access_code_tag_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_correlate_access_code_tag_bb_sptr
    __del__ = lambda self : None;
    def set_access_code(self, *args, **kwargs):
        """set_access_code(self, string access_code) -> bool"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr_set_access_code(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_correlate_access_code_tag_bb_sptr_check_topology(self, *args, **kwargs)

digital_correlate_access_code_tag_bb_sptr_swigregister = _digital_swig.digital_correlate_access_code_tag_bb_sptr_swigregister
digital_correlate_access_code_tag_bb_sptr_swigregister(digital_correlate_access_code_tag_bb_sptr)

digital_correlate_access_code_tag_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def correlate_access_code_tag_bb(*args, **kwargs):
  """
    correlate_access_code_tag_bb(string access_code, int threshold, string tag_name) -> digital_correlate_access_code_tag_bb_sptr

    Examine input for specified access code, one bit at a time.

    input: stream of bits, 1 bit per input byte (data in LSB) output: unaltered stream of bits (plus tags)

    This block annotates the input stream with tags. The tags have key name [tag_name], specified in the constructor. Used for searching an input data stream for preambles, etc.
    """
  return _digital_swig.correlate_access_code_tag_bb(*args, **kwargs)
class digital_costas_loop_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_costas_loop_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_costas_loop_cc_sptr
        __init__(self,  p) -> digital_costas_loop_cc_sptr
        """
        this = _digital_swig.new_digital_costas_loop_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_costas_loop_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_costas_loop_cc_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_costas_loop_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_costas_loop_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_costas_loop_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_costas_loop_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_costas_loop_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_costas_loop_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_costas_loop_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_costas_loop_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_costas_loop_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_costas_loop_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_costas_loop_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_costas_loop_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_costas_loop_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_costas_loop_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_costas_loop_cc_sptr_check_topology(self, *args, **kwargs)

    def update_gains(self):
        """update_gains(self)"""
        return _digital_swig.digital_costas_loop_cc_sptr_update_gains(self)

    def advance_loop(self, *args, **kwargs):
        """advance_loop(self, float error)"""
        return _digital_swig.digital_costas_loop_cc_sptr_advance_loop(self, *args, **kwargs)

    def phase_wrap(self):
        """phase_wrap(self)"""
        return _digital_swig.digital_costas_loop_cc_sptr_phase_wrap(self)

    def frequency_limit(self):
        """frequency_limit(self)"""
        return _digital_swig.digital_costas_loop_cc_sptr_frequency_limit(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """set_loop_bandwidth(self, float bw)"""
        return _digital_swig.digital_costas_loop_cc_sptr_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """set_damping_factor(self, float df)"""
        return _digital_swig.digital_costas_loop_cc_sptr_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """set_alpha(self, float alpha)"""
        return _digital_swig.digital_costas_loop_cc_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """set_beta(self, float beta)"""
        return _digital_swig.digital_costas_loop_cc_sptr_set_beta(self, *args, **kwargs)

    def set_frequency(self, *args, **kwargs):
        """set_frequency(self, float freq)"""
        return _digital_swig.digital_costas_loop_cc_sptr_set_frequency(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """set_phase(self, float phase)"""
        return _digital_swig.digital_costas_loop_cc_sptr_set_phase(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """get_loop_bandwidth(self) -> float"""
        return _digital_swig.digital_costas_loop_cc_sptr_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """get_damping_factor(self) -> float"""
        return _digital_swig.digital_costas_loop_cc_sptr_get_damping_factor(self)

    def get_alpha(self):
        """get_alpha(self) -> float"""
        return _digital_swig.digital_costas_loop_cc_sptr_get_alpha(self)

    def get_beta(self):
        """get_beta(self) -> float"""
        return _digital_swig.digital_costas_loop_cc_sptr_get_beta(self)

    def get_frequency(self):
        """get_frequency(self) -> float"""
        return _digital_swig.digital_costas_loop_cc_sptr_get_frequency(self)

    def get_phase(self):
        """get_phase(self) -> float"""
        return _digital_swig.digital_costas_loop_cc_sptr_get_phase(self)

digital_costas_loop_cc_sptr_swigregister = _digital_swig.digital_costas_loop_cc_sptr_swigregister
digital_costas_loop_cc_sptr_swigregister(digital_costas_loop_cc_sptr)

digital_costas_loop_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def costas_loop_cc(*args, **kwargs):
  """
    costas_loop_cc(float loop_bw, int order) -> digital_costas_loop_cc_sptr

    Carrier tracking PLL for QPSK

    input: complex; output: complex 
    The Costas loop can have two output streams: stream 1 is the baseband I and Q; stream 2 is the normalized frequency of the loop.

    must be 2, 4, or 8.
    """
  return _digital_swig.costas_loop_cc(*args, **kwargs)
class digital_cpmmod_bc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_cpmmod_bc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_cpmmod_bc_sptr
        __init__(self,  p) -> digital_cpmmod_bc_sptr
        """
        this = _digital_swig.new_digital_cpmmod_bc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_cpmmod_bc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_cpmmod_bc_sptr
    __del__ = lambda self : None;
    def get_taps(self):
        """
        get_taps(self) -> __dummy_4__

        Return the phase response FIR taps.
        """
        return _digital_swig.digital_cpmmod_bc_sptr_get_taps(self)

    def primitive_connect(self, *args):
        """
        primitive_connect(self, gr_basic_block_sptr block)
        primitive_connect(self, gr_basic_block_sptr src, int src_port, gr_basic_block_sptr dst, 
            int dst_port)
        """
        return _digital_swig.digital_cpmmod_bc_sptr_primitive_connect(self, *args)

    def primitive_disconnect(self, *args):
        """
        primitive_disconnect(self, gr_basic_block_sptr block)
        primitive_disconnect(self, gr_basic_block_sptr src, int src_port, gr_basic_block_sptr dst, 
            int dst_port)
        """
        return _digital_swig.digital_cpmmod_bc_sptr_primitive_disconnect(self, *args)

    def disconnect_all(self):
        """disconnect_all(self)"""
        return _digital_swig.digital_cpmmod_bc_sptr_disconnect_all(self)

    def lock(self):
        """lock(self)"""
        return _digital_swig.digital_cpmmod_bc_sptr_lock(self)

    def unlock(self):
        """unlock(self)"""
        return _digital_swig.digital_cpmmod_bc_sptr_unlock(self)

    def to_hier_block2(self):
        """to_hier_block2(self) -> gr_hier_block2_sptr"""
        return _digital_swig.digital_cpmmod_bc_sptr_to_hier_block2(self)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_cpmmod_bc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_cpmmod_bc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_cpmmod_bc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_cpmmod_bc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_cpmmod_bc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_cpmmod_bc_sptr_check_topology(self, *args, **kwargs)

digital_cpmmod_bc_sptr_swigregister = _digital_swig.digital_cpmmod_bc_sptr_swigregister
digital_cpmmod_bc_sptr_swigregister(digital_cpmmod_bc_sptr)

digital_cpmmod_bc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def cpmmod_bc(*args, **kwargs):
  """
    cpmmod_bc(int type, float h, unsigned int samples_per_sym, unsigned int L, 
        double beta = 0.3) -> digital_cpmmod_bc_sptr

    Generic CPM modulator.

    Examples:


    The input of this block are symbols from an M-ary alphabet +/-1, +/-3, ..., +/-(M-1). Usually, M = 2 and therefore, the valid inputs are +/-1. The modulator will silently accept any other inputs, though. The output is the phase-modulated signal.

    Args:
        type : The modulation type. Can be one of LREC, LRC, LSRC, TFM or GAUSSIAN. See gr_cpm::phase_response() for a detailed description.
        h : The modulation index.  is the maximum phase change that can occur between two symbols, i.e., if you only send ones, the phase will increase by  every  samples. Set this to 0.5 for Minimum Shift Keying variants.
        samples_per_sym : Samples per symbol.
        L : The length of the phase duration in symbols. For L=1, this yields full- response CPM symbols, for L > 1, partial-response.
        beta : For LSRC, this is the rolloff factor. For Gaussian pulses, this is the 3 dB time-bandwidth product.
    """
  return _digital_swig.cpmmod_bc(*args, **kwargs)

def update_crc32(*args, **kwargs):
  """
    update_crc32(unsigned int crc, string buf) -> unsigned int

    update running CRC-32

    Update a running CRC with the bytes buf[0..len-1] The CRC should be initialized to all 1's, and the transmitted value is the 1's complement of the final running CRC. The resulting CRC should be transmitted in big endian order.
    """
  return _digital_swig.update_crc32(*args, **kwargs)

def crc32(*args, **kwargs):
  """crc32(string buf) -> unsigned int"""
  return _digital_swig.crc32(*args, **kwargs)
class digital_descrambler_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_descrambler_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_descrambler_bb_sptr
        __init__(self,  p) -> digital_descrambler_bb_sptr
        """
        this = _digital_swig.new_digital_descrambler_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_descrambler_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_descrambler_bb_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_descrambler_bb_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_descrambler_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_descrambler_bb_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_descrambler_bb_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_descrambler_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_descrambler_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_descrambler_bb_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_descrambler_bb_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_descrambler_bb_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_descrambler_bb_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_descrambler_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_descrambler_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_descrambler_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_descrambler_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_descrambler_bb_sptr_check_topology(self, *args, **kwargs)

digital_descrambler_bb_sptr_swigregister = _digital_swig.digital_descrambler_bb_sptr_swigregister
digital_descrambler_bb_sptr_swigregister(digital_descrambler_bb_sptr)

digital_descrambler_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def descrambler_bb(*args, **kwargs):
  """
    descrambler_bb(int mask, int seed, int len) -> digital_descrambler_bb_sptr

    Descramble an input stream using an LFSR. This block works on the LSB only of the input data stream, i.e., on an "unpacked binary" stream, and produces the same format on its output.

    Args:
        mask : Polynomial mask for LFSR
        seed : Initial shift register contents
        len : Shift register length
    """
  return _digital_swig.descrambler_bb(*args, **kwargs)
class digital_diff_decoder_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_diff_decoder_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_diff_decoder_bb_sptr
        __init__(self,  p) -> digital_diff_decoder_bb_sptr
        """
        this = _digital_swig.new_digital_diff_decoder_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_diff_decoder_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_diff_decoder_bb_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_diff_decoder_bb_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_diff_decoder_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_diff_decoder_bb_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_diff_decoder_bb_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_diff_decoder_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_diff_decoder_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_diff_decoder_bb_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_diff_decoder_bb_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_diff_decoder_bb_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_diff_decoder_bb_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_diff_decoder_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_diff_decoder_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_diff_decoder_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_diff_decoder_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_diff_decoder_bb_sptr_check_topology(self, *args, **kwargs)

digital_diff_decoder_bb_sptr_swigregister = _digital_swig.digital_diff_decoder_bb_sptr_swigregister
digital_diff_decoder_bb_sptr_swigregister(digital_diff_decoder_bb_sptr)

digital_diff_decoder_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def diff_decoder_bb(*args, **kwargs):
  """
    diff_decoder_bb(unsigned int modulus) -> digital_diff_decoder_bb_sptr

    y[0] = (x[0] - x[-1]) % M

    Uses current and previous symbols and the alphabet modulus to perform differential decoding.
    """
  return _digital_swig.diff_decoder_bb(*args, **kwargs)
class digital_diff_encoder_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_diff_encoder_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_diff_encoder_bb_sptr
        __init__(self,  p) -> digital_diff_encoder_bb_sptr
        """
        this = _digital_swig.new_digital_diff_encoder_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_diff_encoder_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_diff_encoder_bb_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_diff_encoder_bb_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_diff_encoder_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_diff_encoder_bb_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_diff_encoder_bb_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_diff_encoder_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_diff_encoder_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_diff_encoder_bb_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_diff_encoder_bb_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_diff_encoder_bb_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_diff_encoder_bb_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_diff_encoder_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_diff_encoder_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_diff_encoder_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_diff_encoder_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_diff_encoder_bb_sptr_check_topology(self, *args, **kwargs)

digital_diff_encoder_bb_sptr_swigregister = _digital_swig.digital_diff_encoder_bb_sptr_swigregister
digital_diff_encoder_bb_sptr_swigregister(digital_diff_encoder_bb_sptr)

digital_diff_encoder_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def diff_encoder_bb(*args, **kwargs):
  """
    diff_encoder_bb(unsigned int modulus) -> digital_diff_encoder_bb_sptr

    y[0] = (x[0] + y[-1]) % M

    Uses current and previous symbols and the alphabet modulus to perform differential encoding.
    """
  return _digital_swig.diff_encoder_bb(*args, **kwargs)
class digital_diff_phasor_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_diff_phasor_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_diff_phasor_cc_sptr
        __init__(self,  p) -> digital_diff_phasor_cc_sptr
        """
        this = _digital_swig.new_digital_diff_phasor_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_diff_phasor_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_diff_phasor_cc_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_diff_phasor_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_diff_phasor_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_diff_phasor_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_diff_phasor_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_diff_phasor_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_diff_phasor_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_diff_phasor_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_diff_phasor_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_diff_phasor_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_diff_phasor_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_diff_phasor_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_diff_phasor_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_diff_phasor_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_diff_phasor_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_diff_phasor_cc_sptr_check_topology(self, *args, **kwargs)

digital_diff_phasor_cc_sptr_swigregister = _digital_swig.digital_diff_phasor_cc_sptr_swigregister
digital_diff_phasor_cc_sptr_swigregister(digital_diff_phasor_cc_sptr)

digital_diff_phasor_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def diff_phasor_cc():
  """diff_phasor_cc() -> digital_diff_phasor_cc_sptr"""
  return _digital_swig.diff_phasor_cc()
class digital_fll_band_edge_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_fll_band_edge_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_fll_band_edge_cc_sptr
        __init__(self,  p) -> digital_fll_band_edge_cc_sptr
        """
        this = _digital_swig.new_digital_fll_band_edge_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_fll_band_edge_cc_sptr
    __del__ = lambda self : None;
    def set_loop_bandwidth(self, *args, **kwargs):
        """set_loop_bandwidth(self, float bw)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """set_damping_factor(self, float df)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """set_alpha(self, float alpha)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """set_beta(self, float beta)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_beta(self, *args, **kwargs)

    def set_samples_per_symbol(self, *args, **kwargs):
        """
        set_samples_per_symbol(self, float sps)

        Set the number of samples per symbol.

        Set's the number of samples per symbol the system should use. This value is uesd to calculate the filter taps and will force a recalculation.
        """
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_samples_per_symbol(self, *args, **kwargs)

    def set_rolloff(self, *args, **kwargs):
        """
        set_rolloff(self, float rolloff)

        Set the rolloff factor of the shaping filter.

        This sets the rolloff factor that is used in the pulse shaping filter and is used to calculate the filter taps. Changing this will force a recalculation of the filter taps.

        This should be the same value that is used in the transmitter's pulse shaping filter. It must be between 0 and 1 and is usually between 0.2 and 0.5 (where 0.22 and 0.35 are commonly used values).
        """
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_rolloff(self, *args, **kwargs)

    def set_filter_size(self, *args, **kwargs):
        """
        set_filter_size(self, int filter_size)

        Set the number of taps in the filter.

        This sets the number of taps in the band-edge filters. Setting this will force a recalculation of the filter taps.

        This should be about the same number of taps used in the transmitter's shaping filter and also not very large. A large number of taps will result in a large delay between input and frequency estimation, and so will not be as accurate. Between 30 and 70 taps is usual.
        """
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_filter_size(self, *args, **kwargs)

    def set_frequency(self, *args, **kwargs):
        """set_frequency(self, float freq)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_frequency(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """set_phase(self, float phase)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_phase(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """get_loop_bandwidth(self) -> float"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """get_damping_factor(self) -> float"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_damping_factor(self)

    def get_alpha(self):
        """get_alpha(self) -> float"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_alpha(self)

    def get_beta(self):
        """get_beta(self) -> float"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_beta(self)

    def get_samples_per_symbol(self):
        """
        get_samples_per_symbol(self) -> float

        Returns the number of sampler per symbol used for the filter.
        """
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_samples_per_symbol(self)

    def get_rolloff(self):
        """
        get_rolloff(self) -> float

        Returns the rolloff factor used for the filter.
        """
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_rolloff(self)

    def get_filter_size(self):
        """
        get_filter_size(self) -> int

        Returns the number of taps of the filter.
        """
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_filter_size(self)

    def get_frequency(self):
        """get_frequency(self) -> float"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_frequency(self)

    def get_phase(self):
        """get_phase(self) -> float"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_get_phase(self)

    def print_taps(self):
        """
        print_taps(self)

        Print the taps to screen.
        """
        return _digital_swig.digital_fll_band_edge_cc_sptr_print_taps(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_check_topology(self, *args, **kwargs)

    def update_gains(self):
        """update_gains(self)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_update_gains(self)

    def advance_loop(self, *args, **kwargs):
        """advance_loop(self, float error)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_advance_loop(self, *args, **kwargs)

    def phase_wrap(self):
        """phase_wrap(self)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_phase_wrap(self)

    def frequency_limit(self):
        """frequency_limit(self)"""
        return _digital_swig.digital_fll_band_edge_cc_sptr_frequency_limit(self)

digital_fll_band_edge_cc_sptr_swigregister = _digital_swig.digital_fll_band_edge_cc_sptr_swigregister
digital_fll_band_edge_cc_sptr_swigregister(digital_fll_band_edge_cc_sptr)

digital_fll_band_edge_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def fll_band_edge_cc(*args, **kwargs):
  """
    fll_band_edge_cc(float samps_per_sym, float rolloff, int filter_size, 
        float bandwidth) -> digital_fll_band_edge_cc_sptr

    Frequency Lock Loop using band-edge filters.

    The frequency lock loop derives a band-edge filter that covers the upper and lower bandwidths of a digitally-modulated signal. The bandwidth range is determined by the excess bandwidth (e.g., rolloff factor) of the modulated signal. The placement in frequency of the band-edges is determined by the oversampling ratio (number of samples per symbol) and the excess bandwidth. The size of the filters should be fairly large so as to average over a number of symbols.

    The FLL works by filtering the upper and lower band edges into x_u(t) and x_l(t), respectively. These are combined to form cc(t) = x_u(t) + x_l(t) and ss(t) = x_u(t) - x_l(t). Combining these to form the signal e(t) = Re{cc(t) 	imes ss(t)^*} (where ^* is the complex conjugate) provides an error signal at the DC term that is directly proportional to the carrier frequency. We then make a second-order loop using the error signal that is the running average of e(t).

    In practice, the above equation can be simplified by just comparing the absolute value squared of the output of both filters: abs(x_l(t))^2 - abs(x_u(t))^2 = norm(x_l(t)) - norm(x_u(t)).

    In theory, the band-edge filter is the derivative of the matched filter in frequency, (H_be(f) = frac{H(f)}{df}). In practice, this comes down to a quarter sine wave at the point of the matched filter's rolloff (if it's a raised-cosine, the derivative of a cosine is a sine). Extend this sine by another quarter wave to make a half wave around the band-edges is equivalent in time to the sum of two sinc functions. The baseband filter fot the band edges is therefore derived from this sum of sincs. The band edge filters are then just the baseband signal modulated to the correct place in frequency. All of these calculations are done in the 'design_filter' function.

    Note: We use FIR filters here because the filters have to have a flat phase response over the entire frequency range to allow their comparisons to be valid.

    It is very important that the band edge filters be the derivatives of the pulse shaping filter, and that they be linear phase. Otherwise, the variance of the error will be very large.

    Build the FLL
    """
  return _digital_swig.fll_band_edge_cc(*args, **kwargs)
class digital_framer_sink_1_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_framer_sink_1)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_framer_sink_1_sptr
        __init__(self,  p) -> digital_framer_sink_1_sptr
        """
        this = _digital_swig.new_digital_framer_sink_1_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_framer_sink_1_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_framer_sink_1_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_framer_sink_1_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_framer_sink_1_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_framer_sink_1_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_framer_sink_1_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_framer_sink_1_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_framer_sink_1_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_framer_sink_1_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_framer_sink_1_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_framer_sink_1_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_framer_sink_1_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_framer_sink_1_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_framer_sink_1_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_framer_sink_1_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_framer_sink_1_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_framer_sink_1_sptr_check_topology(self, *args, **kwargs)

digital_framer_sink_1_sptr_swigregister = _digital_swig.digital_framer_sink_1_sptr_swigregister
digital_framer_sink_1_sptr_swigregister(digital_framer_sink_1_sptr)

digital_framer_sink_1_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def framer_sink_1(*args, **kwargs):
  """
    framer_sink_1(gr_msg_queue_sptr target_queue) -> digital_framer_sink_1_sptr

    Given a stream of bits and access_code flags, assemble packets.

    input: stream of bytes from gr_correlate_access_code_bb output: none. Pushes assembled packet into target queue.

    The framer expects a fixed length header of 2 16-bit shorts containing the payload length, followed by the payload. If the 2 16-bit shorts are not identical, this packet is ignored. Better algs are welcome.

    The input data consists of bytes that have two bits used. Bit 0, the LSB, contains the data bit. Bit 1 if set, indicates that the corresponding bit is the the first bit of the packet. That is, this bit is the first one after the access code.
    """
  return _digital_swig.framer_sink_1(*args, **kwargs)
class digital_glfsr_source_b_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_glfsr_source_b)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_glfsr_source_b_sptr
        __init__(self,  p) -> digital_glfsr_source_b_sptr
        """
        this = _digital_swig.new_digital_glfsr_source_b_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_glfsr_source_b_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_glfsr_source_b_sptr
    __del__ = lambda self : None;
    def period(self):
        """period(self) -> unsigned int"""
        return _digital_swig.digital_glfsr_source_b_sptr_period(self)

    def mask(self):
        """mask(self) -> int"""
        return _digital_swig.digital_glfsr_source_b_sptr_mask(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_glfsr_source_b_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_glfsr_source_b_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_glfsr_source_b_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_glfsr_source_b_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_glfsr_source_b_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_glfsr_source_b_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_glfsr_source_b_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_glfsr_source_b_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_glfsr_source_b_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_glfsr_source_b_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_glfsr_source_b_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_glfsr_source_b_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_glfsr_source_b_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_glfsr_source_b_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_glfsr_source_b_sptr_check_topology(self, *args, **kwargs)

digital_glfsr_source_b_sptr_swigregister = _digital_swig.digital_glfsr_source_b_sptr_swigregister
digital_glfsr_source_b_sptr_swigregister(digital_glfsr_source_b_sptr)

digital_glfsr_source_b_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def glfsr_source_b(*args, **kwargs):
  """
    glfsr_source_b(int degree, bool repeat = True, int mask = 0, int seed = 1) -> digital_glfsr_source_b_sptr

    Galois LFSR pseudo-random source.

    Args:
        degree : Degree of shift register must be in [1, 32]. If mask is 0, the degree determines a default mask (see digital_impl_glfsr.cc for the mapping).
        repeat : Set to repeat sequence.
        mask : Allows a user-defined bit mask for indexes of the shift register to feed back.
        seed : Initial setting for values in shift register.
    """
  return _digital_swig.glfsr_source_b(*args, **kwargs)
class digital_glfsr_source_f_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_glfsr_source_f)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_glfsr_source_f_sptr
        __init__(self,  p) -> digital_glfsr_source_f_sptr
        """
        this = _digital_swig.new_digital_glfsr_source_f_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_glfsr_source_f_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_glfsr_source_f_sptr
    __del__ = lambda self : None;
    def period(self):
        """period(self) -> unsigned int"""
        return _digital_swig.digital_glfsr_source_f_sptr_period(self)

    def mask(self):
        """mask(self) -> int"""
        return _digital_swig.digital_glfsr_source_f_sptr_mask(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_glfsr_source_f_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_glfsr_source_f_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_glfsr_source_f_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_glfsr_source_f_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_glfsr_source_f_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_glfsr_source_f_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_glfsr_source_f_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_glfsr_source_f_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_glfsr_source_f_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_glfsr_source_f_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_glfsr_source_f_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_glfsr_source_f_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_glfsr_source_f_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_glfsr_source_f_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_glfsr_source_f_sptr_check_topology(self, *args, **kwargs)

digital_glfsr_source_f_sptr_swigregister = _digital_swig.digital_glfsr_source_f_sptr_swigregister
digital_glfsr_source_f_sptr_swigregister(digital_glfsr_source_f_sptr)

digital_glfsr_source_f_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def glfsr_source_f(*args, **kwargs):
  """
    glfsr_source_f(int degree, bool repeat = True, int mask = 0, int seed = 1) -> digital_glfsr_source_f_sptr

    Galois LFSR pseudo-random source generating float outputs -1.0 - 1.0.

    Args:
        degree : Degree of shift register must be in [1, 32]. If mask is 0, the degree determines a default mask (see digital_impl_glfsr.cc for the mapping).
        repeat : Set to repeat sequence.
        mask : Allows a user-defined bit mask for indexes of the shift register to feed back.
        seed : Initial setting for values in shift register.
    """
  return _digital_swig.glfsr_source_f(*args, **kwargs)
class digital_gmskmod_bc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_gmskmod_bc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_gmskmod_bc_sptr
        __init__(self,  p) -> digital_gmskmod_bc_sptr
        """
        this = _digital_swig.new_digital_gmskmod_bc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_gmskmod_bc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_gmskmod_bc_sptr
    __del__ = lambda self : None;
    def get_taps(self):
        """get_taps(self) -> __dummy_4__"""
        return _digital_swig.digital_gmskmod_bc_sptr_get_taps(self)

    def primitive_connect(self, *args):
        """
        primitive_connect(self, gr_basic_block_sptr block)
        primitive_connect(self, gr_basic_block_sptr src, int src_port, gr_basic_block_sptr dst, 
            int dst_port)
        """
        return _digital_swig.digital_gmskmod_bc_sptr_primitive_connect(self, *args)

    def primitive_disconnect(self, *args):
        """
        primitive_disconnect(self, gr_basic_block_sptr block)
        primitive_disconnect(self, gr_basic_block_sptr src, int src_port, gr_basic_block_sptr dst, 
            int dst_port)
        """
        return _digital_swig.digital_gmskmod_bc_sptr_primitive_disconnect(self, *args)

    def disconnect_all(self):
        """disconnect_all(self)"""
        return _digital_swig.digital_gmskmod_bc_sptr_disconnect_all(self)

    def lock(self):
        """lock(self)"""
        return _digital_swig.digital_gmskmod_bc_sptr_lock(self)

    def unlock(self):
        """unlock(self)"""
        return _digital_swig.digital_gmskmod_bc_sptr_unlock(self)

    def to_hier_block2(self):
        """to_hier_block2(self) -> gr_hier_block2_sptr"""
        return _digital_swig.digital_gmskmod_bc_sptr_to_hier_block2(self)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_gmskmod_bc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_gmskmod_bc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_gmskmod_bc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_gmskmod_bc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_gmskmod_bc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_gmskmod_bc_sptr_check_topology(self, *args, **kwargs)

digital_gmskmod_bc_sptr_swigregister = _digital_swig.digital_gmskmod_bc_sptr_swigregister
digital_gmskmod_bc_sptr_swigregister(digital_gmskmod_bc_sptr)

digital_gmskmod_bc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def gmskmod_bc(samples_per_sym = 2, bt = 0.3, L = 4):
  """
    gmskmod_bc(unsigned int samples_per_sym = 2, double bt = 0.3, 
        unsigned int L = 4) -> digital_gmskmod_bc_sptr

    GMSK modulator.

    The input of this block are symbols from an M-ary alphabet +/-1, +/-3, ..., +/-(M-1). Usually, M = 2 and therefore, the valid inputs are +/-1. The modulator will silently accept any other inputs, though. The output is the phase-modulated signal.

    Args:
        samples_per_sym : Samples per symbol.
        bt : The 3 dB time-bandwidth product.
        L : The length of the phase duration in symbols. The Gaussian pulse is truncated after L symbols.
    """
  return _digital_swig.gmskmod_bc(samples_per_sym, bt, L)
class digital_kurtotic_equalizer_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_kurtotic_equalizer_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_kurtotic_equalizer_cc_sptr
        __init__(self,  p) -> digital_kurtotic_equalizer_cc_sptr
        """
        this = _digital_swig.new_digital_kurtotic_equalizer_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_kurtotic_equalizer_cc_sptr
    __del__ = lambda self : None;
    def set_gain(self, *args, **kwargs):
        """set_gain(self, float mu)"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_set_gain(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(self, gr_complex_vector taps)"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_kurtotic_equalizer_cc_sptr_check_topology(self, *args, **kwargs)

digital_kurtotic_equalizer_cc_sptr_swigregister = _digital_swig.digital_kurtotic_equalizer_cc_sptr_swigregister
digital_kurtotic_equalizer_cc_sptr_swigregister(digital_kurtotic_equalizer_cc_sptr)

digital_kurtotic_equalizer_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def kurtotic_equalizer_cc(*args, **kwargs):
  """
    kurtotic_equalizer_cc(int num_taps, float mu) -> digital_kurtotic_equalizer_cc_sptr

    Implements a kurtosis-based adaptive equalizer on complex stream

    "Y. Guo, J. Zhao, Y. Sun, "Sign kurtosis maximization based blind equalization algorithm," IEEE Conf. on Control, Automation,
     Robotics and Vision, Vol. 3, Dec. 2004, pp. 2052 - 2057.".
    """
  return _digital_swig.kurtotic_equalizer_cc(*args, **kwargs)
class digital_lms_dd_equalizer_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_lms_dd_equalizer_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_lms_dd_equalizer_cc_sptr
        __init__(self,  p) -> digital_lms_dd_equalizer_cc_sptr
        """
        this = _digital_swig.new_digital_lms_dd_equalizer_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_lms_dd_equalizer_cc_sptr
    __del__ = lambda self : None;
    def get_gain(self):
        """get_gain(self) -> float"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_get_gain(self)

    def set_gain(self, *args, **kwargs):
        """set_gain(self, float mu)"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_set_gain(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_lms_dd_equalizer_cc_sptr_check_topology(self, *args, **kwargs)

digital_lms_dd_equalizer_cc_sptr_swigregister = _digital_swig.digital_lms_dd_equalizer_cc_sptr_swigregister
digital_lms_dd_equalizer_cc_sptr_swigregister(digital_lms_dd_equalizer_cc_sptr)

digital_lms_dd_equalizer_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def lms_dd_equalizer_cc(*args, **kwargs):
  """
    lms_dd_equalizer_cc(int num_taps, float mu, int sps, digital_constellation_sptr cnst) -> digital_lms_dd_equalizer_cc_sptr

    Least-Mean-Square Decision Directed Equalizer (complex in/out)

    This block implements an LMS-based decision-directed equalizer. It uses a set of weights, w, to correlate against the inputs, u, and a decisions is then made from this output. The error in the decision is used to update teh weight vector.

    y[n] = conj(w[n]) u[n] d[n] = decision(y[n]) e[n] = d[n] - y[n] w[n+1] = w[n] + mu u[n] conj(e[n])

    Where mu is a gain value (between 0 and 1 and usualy small, around 0.001 - 0.01.

    This block uses the digital_constellation object for making the decision from y[n]. Create the constellation object for whatever constellation is to be used and pass in the object. In Python, you can use something like: self.constellation = digital.constellation_qpsk() To create a QPSK constellation (see the digital_constellation block for more details as to what constellations are available or how to create your own). You then pass the object to this block as an sptr, or using "self.constellation.base()".

    The theory for this algorithm can be found in Chapter 9 of: S. Haykin, Adaptive Filter Theory, Upper Saddle River, NJ: Prentice Hall, 1996.
    """
  return _digital_swig.lms_dd_equalizer_cc(*args, **kwargs)
class digital_map_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_map_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_map_bb_sptr
        __init__(self,  p) -> digital_map_bb_sptr
        """
        this = _digital_swig.new_digital_map_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_map_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_map_bb_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_map_bb_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_map_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_map_bb_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_map_bb_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_map_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_map_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_map_bb_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_map_bb_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_map_bb_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_map_bb_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_map_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_map_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_map_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_map_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_map_bb_sptr_check_topology(self, *args, **kwargs)

digital_map_bb_sptr_swigregister = _digital_swig.digital_map_bb_sptr_swigregister
digital_map_bb_sptr_swigregister(digital_map_bb_sptr)

digital_map_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def map_bb(*args, **kwargs):
  """
    map_bb(__dummy_3__ map) -> digital_map_bb_sptr

    output[i] = map[input[i]]

    This block maps an incoming signal to the value in the map. The block expects that the incoming signal has a maximum value of len(map)-1.

    -> output[i] = map[input[i]]

    Args:
        map : a vector of integers.
    """
  return _digital_swig.map_bb(*args, **kwargs)
class digital_mpsk_receiver_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_mpsk_receiver_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_mpsk_receiver_cc_sptr
        __init__(self,  p) -> digital_mpsk_receiver_cc_sptr
        """
        this = _digital_swig.new_digital_mpsk_receiver_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_mpsk_receiver_cc_sptr
    __del__ = lambda self : None;
    def modulation_order(self):
        """
        modulation_order(self) -> float

        Returns the modulation order (M) currently set.
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_modulation_order(self)

    def mu(self):
        """
        mu(self) -> float

        Returns current value of mu.
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_mu(self)

    def omega(self):
        """
        omega(self) -> float

        Returns current value of omega.
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_omega(self)

    def gain_mu(self):
        """
        gain_mu(self) -> float

        Returns mu gain factor.
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_gain_mu(self)

    def gain_omega(self):
        """
        gain_omega(self) -> float

        Returns omega gain factor.
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_gain_omega(self)

    def gain_omega_rel(self):
        """
        gain_omega_rel(self) -> float

        Returns the relative omega limit.
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_gain_omega_rel(self)

    def set_modulation_order(self, *args, **kwargs):
        """
        set_modulation_order(self, unsigned int M)

        Sets the modulation order (M) currently.
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_modulation_order(self, *args, **kwargs)

    def set_mu(self, *args, **kwargs):
        """
        set_mu(self, float mu)

        Sets value of mu.
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_mu(self, *args, **kwargs)

    def set_omega(self, *args, **kwargs):
        """
        set_omega(self, float omega)

        Sets value of omega and its min and max values.
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_omega(self, *args, **kwargs)

    def set_theta(self, *args, **kwargs):
        """
        set_theta(self, float theta)

        Sets value of theta.
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_theta(self, *args, **kwargs)

    def set_gain_mu(self, *args, **kwargs):
        """
        set_gain_mu(self, float gain_mu)

        Sets value for mu gain factor.
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_gain_mu(self, *args, **kwargs)

    def set_gain_omega(self, *args, **kwargs):
        """
        set_gain_omega(self, float gain_omega)

        Sets value for omega gain factor.
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_gain_omega(self, *args, **kwargs)

    def set_gain_omega_rel(self, *args, **kwargs):
        """
        set_gain_omega_rel(self, float omega_rel)

        Sets the relative omega limit and resets omega min/max values.
        """
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_gain_omega_rel(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_check_topology(self, *args, **kwargs)

    def update_gains(self):
        """update_gains(self)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_update_gains(self)

    def advance_loop(self, *args, **kwargs):
        """advance_loop(self, float error)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_advance_loop(self, *args, **kwargs)

    def phase_wrap(self):
        """phase_wrap(self)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_phase_wrap(self)

    def frequency_limit(self):
        """frequency_limit(self)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_frequency_limit(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """set_loop_bandwidth(self, float bw)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """set_damping_factor(self, float df)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """set_alpha(self, float alpha)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """set_beta(self, float beta)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_beta(self, *args, **kwargs)

    def set_frequency(self, *args, **kwargs):
        """set_frequency(self, float freq)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_frequency(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """set_phase(self, float phase)"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_set_phase(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """get_loop_bandwidth(self) -> float"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """get_damping_factor(self) -> float"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_get_damping_factor(self)

    def get_alpha(self):
        """get_alpha(self) -> float"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_get_alpha(self)

    def get_beta(self):
        """get_beta(self) -> float"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_get_beta(self)

    def get_frequency(self):
        """get_frequency(self) -> float"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_get_frequency(self)

    def get_phase(self):
        """get_phase(self) -> float"""
        return _digital_swig.digital_mpsk_receiver_cc_sptr_get_phase(self)

digital_mpsk_receiver_cc_sptr_swigregister = _digital_swig.digital_mpsk_receiver_cc_sptr_swigregister
digital_mpsk_receiver_cc_sptr_swigregister(digital_mpsk_receiver_cc_sptr)

digital_mpsk_receiver_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def mpsk_receiver_cc(*args, **kwargs):
  """
    mpsk_receiver_cc(unsigned int M, float theta, float loop_bw, float fmin, 
        float fmax, float mu, float gain_mu, float omega, 
        float gain_omega, float omega_rel) -> digital_mpsk_receiver_cc_sptr

    This block takes care of receiving M-PSK modulated signals through phase, frequency, and symbol synchronization.

    This block takes care of receiving M-PSK modulated signals through phase, frequency, and symbol synchronization. It performs carrier frequency and phase locking as well as symbol timing recovery. It works with (D)BPSK, (D)QPSK, and (D)8PSK as tested currently. It should also work for OQPSK and PI/4 DQPSK.

    The phase and frequency synchronization are based on a Costas loop that finds the error of the incoming signal point compared to its nearest constellation point. The frequency and phase of the NCO are updated according to this error. There are optimized phase error detectors for BPSK and QPSK, but 8PSK is done using a brute-force computation of the constellation points to find the minimum.

    The symbol synchronization is done using a modified Mueller and Muller circuit from the paper:

    "G. R. Danesfahani, T. G. Jeans, "Optimisation of modified Mueller and Muller algorithm," Electronics Letters, Vol. 31, no. 13, 22
     June 1995, pp. 1032 - 1033."

    This circuit interpolates the downconverted sample (using the NCO developed by the Costas loop) every mu samples, then it finds the sampling error based on this and the past symbols and the decision made on the samples. Like the phase error detector, there are optimized decision algorithms for BPSK and QPKS, but 8PSK uses another brute force computation against all possible symbols. The modifications to the M&M used here reduce self-noise.
    """
  return _digital_swig.mpsk_receiver_cc(*args, **kwargs)
class digital_mpsk_snr_est_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_mpsk_snr_est_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_mpsk_snr_est_cc_sptr
        __init__(self,  p) -> digital_mpsk_snr_est_cc_sptr
        """
        this = _digital_swig.new_digital_mpsk_snr_est_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_mpsk_snr_est_cc_sptr
    __del__ = lambda self : None;
    def snr(self):
        """
        snr(self) -> double

        Return the estimated signal-to-noise ratio in decibels.
        """
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_snr(self)

    def type(self):
        """
        type(self) -> snr_est_type_t

        Return the type of estimator in use.
        """
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_type(self)

    def tag_nsample(self):
        """
        tag_nsample(self) -> int

        Return how many samples between SNR tags.
        """
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_tag_nsample(self)

    def alpha(self):
        """
        alpha(self) -> double

        Get the running-average coefficient.
        """
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_alpha(self)

    def set_type(self, *args, **kwargs):
        """
        set_type(self, snr_est_type_t t)

        Set type of estimator to use.
        """
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_set_type(self, *args, **kwargs)

    def set_tag_nsample(self, *args, **kwargs):
        """
        set_tag_nsample(self, int n)

        Set the number of samples between SNR tags.
        """
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_set_tag_nsample(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(self, double alpha)

        Set the running-average coefficient.
        """
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_set_alpha(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_mpsk_snr_est_cc_sptr_check_topology(self, *args, **kwargs)

digital_mpsk_snr_est_cc_sptr_swigregister = _digital_swig.digital_mpsk_snr_est_cc_sptr_swigregister
digital_mpsk_snr_est_cc_sptr_swigregister(digital_mpsk_snr_est_cc_sptr)

digital_mpsk_snr_est_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def mpsk_snr_est_cc(*args, **kwargs):
  """
    mpsk_snr_est_cc(snr_est_type_t type, int tag_nsamples = 10000, double alpha = 0.001) -> digital_mpsk_snr_est_cc_sptr

    A block for computing SNR of a signal.

    This block can be used to monitor and retrieve estimations of the signal SNR. It is designed to work in a flowgraph and passes all incoming data along to its output.

    The block is designed for use with M-PSK signals especially. The type of estimator is specified as the  parameter in the constructor. The estimators tend to trade off performance for accuracy, although experimentation should be done to figure out the right approach for a given implementation. Further, the current set of estimators are designed and proven theoretically under AWGN conditions; some amount of error should be assumed and/or estimated for real channel conditions.

    Factory function returning shared pointer of this class

    Parameters:
    """
  return _digital_swig.mpsk_snr_est_cc(*args, **kwargs)
class digital_ofdm_cyclic_prefixer_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_ofdm_cyclic_prefixer)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_ofdm_cyclic_prefixer_sptr
        __init__(self,  p) -> digital_ofdm_cyclic_prefixer_sptr
        """
        this = _digital_swig.new_digital_ofdm_cyclic_prefixer_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_ofdm_cyclic_prefixer_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_ofdm_cyclic_prefixer_sptr_check_topology(self, *args, **kwargs)

digital_ofdm_cyclic_prefixer_sptr_swigregister = _digital_swig.digital_ofdm_cyclic_prefixer_sptr_swigregister
digital_ofdm_cyclic_prefixer_sptr_swigregister(digital_ofdm_cyclic_prefixer_sptr)

digital_ofdm_cyclic_prefixer_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def ofdm_cyclic_prefixer(*args, **kwargs):
  """
    ofdm_cyclic_prefixer(size_t input_size, size_t output_size) -> digital_ofdm_cyclic_prefixer_sptr

    adds a cyclic prefix vector to an input size long ofdm symbol(vector) and converts vector to a stream output_size long.
    """
  return _digital_swig.ofdm_cyclic_prefixer(*args, **kwargs)
class digital_ofdm_frame_acquisition_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_ofdm_frame_acquisition)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_ofdm_frame_acquisition_sptr
        __init__(self,  p) -> digital_ofdm_frame_acquisition_sptr
        """
        this = _digital_swig.new_digital_ofdm_frame_acquisition_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_ofdm_frame_acquisition_sptr
    __del__ = lambda self : None;
    def snr(self):
        """
        snr(self) -> float

        Return an estimate of the SNR of the channel.
        """
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_snr(self)

    def general_work(self, *args, **kwargs):
        """
        general_work(self, int noutput_items, gr_vector_int ninput_items, gr_vector_const_void_star input_items, 
            gr_vector_void_star output_items) -> int
        """
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_general_work(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_ofdm_frame_acquisition_sptr_check_topology(self, *args, **kwargs)

digital_ofdm_frame_acquisition_sptr_swigregister = _digital_swig.digital_ofdm_frame_acquisition_sptr_swigregister
digital_ofdm_frame_acquisition_sptr_swigregister(digital_ofdm_frame_acquisition_sptr)

digital_ofdm_frame_acquisition_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def ofdm_frame_acquisition(*args, **kwargs):
  """
    ofdm_frame_acquisition(unsigned int occupied_carriers, unsigned int fft_length, 
        unsigned int cplen, gr_complex_vector known_symbol, 
        unsigned int max_fft_shift_len = 4) -> digital_ofdm_frame_acquisition_sptr

    take a vector of complex constellation points in from an FFT and performs a correlation and equalization.

    This block takes the output of an FFT of a received OFDM symbol and finds the start of a frame based on two known symbols. It also looks at the surrounding bins in the FFT output for the correlation in case there is a large frequency shift in the data. This block assumes that the fine frequency shift has already been corrected and that the samples fall in the middle of one FFT bin.

    It then uses one of those known symbols to estimate the channel response over all subcarriers and does a simple 1-tap equalization on all subcarriers. This corrects for the phase and amplitude distortion caused by the channel.
    """
  return _digital_swig.ofdm_frame_acquisition(*args, **kwargs)
class digital_ofdm_frame_sink_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_ofdm_frame_sink)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_ofdm_frame_sink_sptr
        __init__(self,  p) -> digital_ofdm_frame_sink_sptr
        """
        this = _digital_swig.new_digital_ofdm_frame_sink_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_ofdm_frame_sink_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_ofdm_frame_sink_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_ofdm_frame_sink_sptr_check_topology(self, *args, **kwargs)

digital_ofdm_frame_sink_sptr_swigregister = _digital_swig.digital_ofdm_frame_sink_sptr_swigregister
digital_ofdm_frame_sink_sptr_swigregister(digital_ofdm_frame_sink_sptr)

digital_ofdm_frame_sink_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def ofdm_frame_sink(*args, **kwargs):
  """
    ofdm_frame_sink(gr_complex_vector sym_position, __dummy_0__ sym_value_out, 
        gr_msg_queue_sptr target_queue, unsigned int occupied_tones, 
        float phase_gain = 0.25, 
        float freq_gain = 0.25*0.25/4) -> digital_ofdm_frame_sink_sptr

    Takes an OFDM symbol in, demaps it into bits of 0's and 1's, packs them into packets, and sends to to a message queue sink.

    NOTE: The mod input parameter simply chooses a pre-defined demapper/slicer. Eventually, we want to be able to pass in a reference to an object to do the demapping and slicing for a given modulation type.
    """
  return _digital_swig.ofdm_frame_sink(*args, **kwargs)
class digital_ofdm_insert_preamble_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_ofdm_insert_preamble)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_ofdm_insert_preamble_sptr
        __init__(self,  p) -> digital_ofdm_insert_preamble_sptr
        """
        this = _digital_swig.new_digital_ofdm_insert_preamble_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_ofdm_insert_preamble_sptr
    __del__ = lambda self : None;
    def enter_preamble(self):
        """enter_preamble(self)"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_enter_preamble(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_ofdm_insert_preamble_sptr_check_topology(self, *args, **kwargs)

digital_ofdm_insert_preamble_sptr_swigregister = _digital_swig.digital_ofdm_insert_preamble_sptr_swigregister
digital_ofdm_insert_preamble_sptr_swigregister(digital_ofdm_insert_preamble_sptr)

digital_ofdm_insert_preamble_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def ofdm_insert_preamble(*args, **kwargs):
  """
    ofdm_insert_preamble(int fft_length, std::vector<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>,std::allocator<(std::vector<(gr_complex,std::allocator<(gr_complex)>)>)>)> preamble) -> digital_ofdm_insert_preamble_sptr

    insert "pre-modulated" preamble symbols before each payload.

    Args:
        fft_length : length of each symbol in samples.
        preamble : vector of symbols that represent the pre-modulated preamble.
    """
  return _digital_swig.ofdm_insert_preamble(*args, **kwargs)
class digital_ofdm_mapper_bcv_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_ofdm_mapper_bcv)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_ofdm_mapper_bcv_sptr
        __init__(self,  p) -> digital_ofdm_mapper_bcv_sptr
        """
        this = _digital_swig.new_digital_ofdm_mapper_bcv_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_ofdm_mapper_bcv_sptr
    __del__ = lambda self : None;
    def msgq(self):
        """msgq(self) -> gr_msg_queue_sptr"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_msgq(self)

    def work(self, *args, **kwargs):
        """
        work(self, int noutput_items, gr_vector_const_void_star input_items, 
            gr_vector_void_star output_items) -> int
        """
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_work(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_ofdm_mapper_bcv_sptr_check_topology(self, *args, **kwargs)

digital_ofdm_mapper_bcv_sptr_swigregister = _digital_swig.digital_ofdm_mapper_bcv_sptr_swigregister
digital_ofdm_mapper_bcv_sptr_swigregister(digital_ofdm_mapper_bcv_sptr)

digital_ofdm_mapper_bcv_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def ofdm_mapper_bcv(*args, **kwargs):
  """
    ofdm_mapper_bcv(gr_complex_vector constellation, unsigned int msgq_limit, 
        unsigned int bits_per_symbol, unsigned int fft_length) -> digital_ofdm_mapper_bcv_sptr

    take a stream of bytes in and map to a vector of complex constellation points suitable for IFFT input to be used in an ofdm modulator. Abstract class must be subclassed with specific mapping.
    """
  return _digital_swig.ofdm_mapper_bcv(*args, **kwargs)
class digital_ofdm_sampler_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_ofdm_sampler)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_ofdm_sampler_sptr
        __init__(self,  p) -> digital_ofdm_sampler_sptr
        """
        this = _digital_swig.new_digital_ofdm_sampler_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_ofdm_sampler_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_ofdm_sampler_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_ofdm_sampler_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_ofdm_sampler_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_ofdm_sampler_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_ofdm_sampler_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_ofdm_sampler_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_ofdm_sampler_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_ofdm_sampler_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_ofdm_sampler_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_ofdm_sampler_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_ofdm_sampler_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_sampler_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_ofdm_sampler_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_ofdm_sampler_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_ofdm_sampler_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_ofdm_sampler_sptr_check_topology(self, *args, **kwargs)

digital_ofdm_sampler_sptr_swigregister = _digital_swig.digital_ofdm_sampler_sptr_swigregister
digital_ofdm_sampler_sptr_swigregister(digital_ofdm_sampler_sptr)

digital_ofdm_sampler_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def ofdm_sampler(*args, **kwargs):
  """
    ofdm_sampler(unsigned int fft_length, unsigned int symbol_length, 
        unsigned int timeout = 1000) -> digital_ofdm_sampler_sptr

    does the rest of the OFDM stuff
    """
  return _digital_swig.ofdm_sampler(*args, **kwargs)
class digital_packet_sink_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_packet_sink)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_packet_sink_sptr
        __init__(self,  p) -> digital_packet_sink_sptr
        """
        this = _digital_swig.new_digital_packet_sink_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_packet_sink_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_packet_sink_sptr
    __del__ = lambda self : None;
    def carrier_sensed(self):
        """
        carrier_sensed(self) -> bool

        return true if we detect carrier
        """
        return _digital_swig.digital_packet_sink_sptr_carrier_sensed(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_packet_sink_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_packet_sink_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_packet_sink_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_packet_sink_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_packet_sink_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_packet_sink_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_packet_sink_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_packet_sink_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_packet_sink_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_packet_sink_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_packet_sink_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_packet_sink_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_packet_sink_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_packet_sink_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_packet_sink_sptr_check_topology(self, *args, **kwargs)

digital_packet_sink_sptr_swigregister = _digital_swig.digital_packet_sink_sptr_swigregister
digital_packet_sink_sptr_swigregister(digital_packet_sink_sptr)

digital_packet_sink_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def packet_sink(*args, **kwargs):
  """
    packet_sink(__dummy_0__ sync_vector, gr_msg_queue_sptr target_queue, 
        int threshold = -1) -> digital_packet_sink_sptr

    process received bits looking for packet sync, header, and process bits into packet

    input: stream of symbols to be sliced.

    output: none. Pushes assembled packet into target queue

    The packet sink takes in a stream of binary symbols that are sliced around 0. The bits are then checked for the  to determine find and decode the packet. It then expects a fixed length header of 2 16-bit shorts containing the payload length, followed by the payload. If the 2 16-bit shorts are not identical, this packet is ignored. Better algs are welcome.

    This block is not very useful anymore as it only works with 2-level modulations such as BPSK or GMSK. The block can generally be replaced with a correlate access code and frame sink blocks.

    Args:
        sync_vector : The synchronization vector as a vector of 1's and 0's.
        target_queue : The message queue that packets are sent to.
        threshold : Number of bits that can be incorrect in the .
    """
  return _digital_swig.packet_sink(*args, **kwargs)
class digital_pfb_clock_sync_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_pfb_clock_sync_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_pfb_clock_sync_ccf_sptr
        __init__(self,  p) -> digital_pfb_clock_sync_ccf_sptr
        """
        this = _digital_swig.new_digital_pfb_clock_sync_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_pfb_clock_sync_ccf_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """
        set_taps(self, __dummy_4__ taps, __dummy_11__ ourtaps, std::vector<(p.gr_fir_ccf,std::allocator<(p.gr_fir_ccf)>)> ourfilter)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_set_taps(self, *args, **kwargs)

    def get_taps(self):
        """
        get_taps(self) -> __dummy_11__

        Returns all of the taps of the matched filter
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_get_taps(self)

    def get_diff_taps(self):
        """
        get_diff_taps(self) -> __dummy_11__

        Returns all of the taps of the derivative filter
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_get_diff_taps(self)

    def get_channel_taps(self, *args, **kwargs):
        """
        get_channel_taps(self, int channel) -> __dummy_4__

        Returns the taps of the matched filter for a particular channel
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_get_channel_taps(self, *args, **kwargs)

    def get_diff_channel_taps(self, *args, **kwargs):
        """
        get_diff_channel_taps(self, int channel) -> __dummy_4__

        Returns the taps in the derivative filter for a particular channel
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_get_diff_channel_taps(self, *args, **kwargs)

    def get_taps_as_string(self):
        """
        get_taps_as_string(self) -> string

        Return the taps as a formatted string for printing
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_get_taps_as_string(self)

    def get_diff_taps_as_string(self):
        """
        get_diff_taps_as_string(self) -> string

        Return the derivative filter taps as a formatted string for printing
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_get_diff_taps_as_string(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """
        set_loop_bandwidth(self, float bw)

        Set the loop bandwidth.

        Set the loop filter's bandwidth to . This should be between 2*pi/200 and 2*pi/100 (in rads/samp). It must also be a positive number.

        When a new damping factor is set, the gains, alpha and beta, of the loop are recalculated by a call to update_gains().
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """
        set_damping_factor(self, float df)

        Set the loop damping factor.

        Set the loop filter's damping factor to . The damping factor should be sqrt(2)/2.0 for critically damped systems. Set it to anything else only if you know what you are doing. It must be a number between 0 and 1.

        When a new damping factor is set, the gains, alpha and beta, of the loop are recalculated by a call to update_gains().
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(self, float alpha)

        Set the loop gain alpha.

        Set's the loop filter's alpha gain parameter.

        This value should really only be set by adjusting the loop bandwidth and damping factor.
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """
        set_beta(self, float beta)

        Set the loop gain beta.

        Set's the loop filter's beta gain parameter.

        This value should really only be set by adjusting the loop bandwidth and damping factor.
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_set_beta(self, *args, **kwargs)

    def set_max_rate_deviation(self, *args, **kwargs):
        """
        set_max_rate_deviation(self, float m)

        Set the maximum deviation from 0 d_rate can have
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_set_max_rate_deviation(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """
        get_loop_bandwidth(self) -> float

        Returns the loop bandwidth.
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """
        get_damping_factor(self) -> float

        Returns the loop damping factor.
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_get_damping_factor(self)

    def get_alpha(self):
        """
        get_alpha(self) -> float

        Returns the loop gain alpha.
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_get_alpha(self)

    def get_beta(self):
        """
        get_beta(self) -> float

        Returns the loop gain beta.
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_get_beta(self)

    def get_clock_rate(self):
        """
        get_clock_rate(self) -> float

        Returns the current clock rate.
        """
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_get_clock_rate(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_pfb_clock_sync_ccf_sptr_check_topology(self, *args, **kwargs)

digital_pfb_clock_sync_ccf_sptr_swigregister = _digital_swig.digital_pfb_clock_sync_ccf_sptr_swigregister
digital_pfb_clock_sync_ccf_sptr_swigregister(digital_pfb_clock_sync_ccf_sptr)

digital_pfb_clock_sync_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def pfb_clock_sync_ccf(*args, **kwargs):
  """
    pfb_clock_sync_ccf(double sps, float loop_bw, __dummy_4__ taps, unsigned int filter_size = 32, 
        float init_phase = 0, 
        float max_rate_deviation = 1.5, int osps = 1) -> digital_pfb_clock_sync_ccf_sptr

    Timing synchronizer using polyphase filterbanks.

    This block performs timing synchronization for PAM signals by minimizing the derivative of the filtered signal, which in turn maximizes the SNR and minimizes ISI.

    This approach works by setting up two filterbanks; one filterbank contains the signal's pulse shaping matched filter (such as a root raised cosine filter), where each branch of the filterbank contains a different phase of the filter. The second filterbank contains the derivatives of the filters in the first filterbank. Thinking of this in the time domain, the first filterbank contains filters that have a sinc shape to them. We want to align the output signal to be sampled at exactly the peak of the sinc shape. The derivative of the sinc contains a zero at the maximum point of the sinc (sinc(0) = 1, sinc(0)' = 0). Furthermore, the region around the zero point is relatively linear. We make use of this fact to generate the error signal.

    If the signal out of the derivative filters is d_i[n] for the ith filter, and the output of the matched filter is x_i[n], we calculate the error as: e[n] = (Re{x_i[n]} * Re{d_i[n]} + Im{x_i[n]} * Im{d_i[n]}) / 2.0 This equation averages the error in the real and imaginary parts. There are two reasons we multiply by the signal itself. First, if the symbol could be positive or negative going, but we want the error term to always tell us to go in the same direction depending on which side of the zero point we are on. The sign of x_i[n] adjusts the error term to do this. Second, the magnitude of x_i[n] scales the error term depending on the symbol's amplitude, so larger signals give us a stronger error term because we have more confidence in that symbol's value. Using the magnitude of x_i[n] instead of just the sign is especially good for signals with low SNR.

    The error signal, e[n], gives us a value proportional to how far away from the zero point we are in the derivative signal. We want to drive this value to zero, so we set up a second order loop. We have two variables for this loop; d_k is the filter number in the filterbank we are on and d_rate is the rate which we travel through the filters in the steady state. That is, due to the natural clock differences between the transmitter and receiver, d_rate represents that difference and would traverse the filter phase paths to keep the receiver locked. Thinking of this as a second-order PLL, the d_rate is the frequency and d_k is the phase. So we update d_rate and d_k using the standard loop equations based on two error signals, d_alpha and d_beta. We have these two values set based on each other for a critically damped system, so in the block constructor, we just ask for "gain," which is d_alpha while d_beta is equal to (gain^2)/4.

    The block's parameters are:

    Build the polyphase filterbank timing synchronizer.
    """
  return _digital_swig.pfb_clock_sync_ccf(*args, **kwargs)
class digital_pfb_clock_sync_fff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_pfb_clock_sync_fff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_pfb_clock_sync_fff_sptr
        __init__(self,  p) -> digital_pfb_clock_sync_fff_sptr
        """
        this = _digital_swig.new_digital_pfb_clock_sync_fff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_pfb_clock_sync_fff_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_pfb_clock_sync_fff_sptr
    __del__ = lambda self : None;
    def set_taps(self, *args, **kwargs):
        """
        set_taps(self, __dummy_4__ taps, __dummy_11__ ourtaps, std::vector<(p.gr_fir_fff,std::allocator<(p.gr_fir_fff)>)> ourfilter)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_set_taps(self, *args, **kwargs)

    def get_taps(self):
        """
        get_taps(self) -> __dummy_11__

        Returns all of the taps of the matched filter
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_get_taps(self)

    def get_diff_taps(self):
        """
        get_diff_taps(self) -> __dummy_11__

        Returns all of the taps of the derivative filter
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_get_diff_taps(self)

    def get_channel_taps(self, *args, **kwargs):
        """
        get_channel_taps(self, int channel) -> __dummy_4__

        Returns the taps of the matched filter for a particular channel
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_get_channel_taps(self, *args, **kwargs)

    def get_diff_channel_taps(self, *args, **kwargs):
        """
        get_diff_channel_taps(self, int channel) -> __dummy_4__

        Returns the taps in the derivative filter for a particular channel
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_get_diff_channel_taps(self, *args, **kwargs)

    def get_taps_as_string(self):
        """
        get_taps_as_string(self) -> string

        Return the taps as a formatted string for printing
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_get_taps_as_string(self)

    def get_diff_taps_as_string(self):
        """
        get_diff_taps_as_string(self) -> string

        Return the derivative filter taps as a formatted string for printing
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_get_diff_taps_as_string(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """
        set_loop_bandwidth(self, float bw)

        Set the loop bandwidth.

        Set the loop filter's bandwidth to . This should be between 2*pi/200 and 2*pi/100 (in rads/samp). It must also be a positive number.

        When a new damping factor is set, the gains, alpha and beta, of the loop are recalculated by a call to update_gains().
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """
        set_damping_factor(self, float df)

        Set the loop damping factor.

        Set the loop filter's damping factor to . The damping factor should be sqrt(2)/2.0 for critically damped systems. Set it to anything else only if you know what you are doing. It must be a number between 0 and 1.

        When a new damping factor is set, the gains, alpha and beta, of the loop are recalculated by a call to update_gains().
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(self, float alpha)

        Set the loop gain alpha.

        Set's the loop filter's alpha gain parameter.

        This value should really only be set by adjusting the loop bandwidth and damping factor.
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """
        set_beta(self, float beta)

        Set the loop gain beta.

        Set's the loop filter's beta gain parameter.

        This value should really only be set by adjusting the loop bandwidth and damping factor.
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_set_beta(self, *args, **kwargs)

    def set_max_rate_deviation(self, *args, **kwargs):
        """
        set_max_rate_deviation(self, float m)

        Set the maximum deviation from 0 d_rate can have
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_set_max_rate_deviation(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """
        get_loop_bandwidth(self) -> float

        Returns the loop bandwidth.
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """
        get_damping_factor(self) -> float

        Returns the loop damping factor.
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_get_damping_factor(self)

    def get_alpha(self):
        """
        get_alpha(self) -> float

        Returns the loop gain alpha.
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_get_alpha(self)

    def get_beta(self):
        """
        get_beta(self) -> float

        Returns the loop gain beta.
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_get_beta(self)

    def get_clock_rate(self):
        """
        get_clock_rate(self) -> float

        Returns the current clock rate.
        """
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_get_clock_rate(self)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_pfb_clock_sync_fff_sptr_check_topology(self, *args, **kwargs)

digital_pfb_clock_sync_fff_sptr_swigregister = _digital_swig.digital_pfb_clock_sync_fff_sptr_swigregister
digital_pfb_clock_sync_fff_sptr_swigregister(digital_pfb_clock_sync_fff_sptr)

digital_pfb_clock_sync_fff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def pfb_clock_sync_fff(*args, **kwargs):
  """
    pfb_clock_sync_fff(double sps, float loop_bw, __dummy_4__ taps, unsigned int filter_size = 32, 
        float init_phase = 0, 
        float max_rate_deviation = 1.5, int osps = 1) -> digital_pfb_clock_sync_fff_sptr

    Timing synchronizer using polyphase filterbanks.

    This block performs timing synchronization for PAM signals by minimizing the derivative of the filtered signal, which in turn maximizes the SNR and minimizes ISI.

    This approach works by setting up two filterbanks; one filterbank contains the signal's pulse shaping matched filter (such as a root raised cosine filter), where each branch of the filterbank contains a different phase of the filter. The second filterbank contains the derivatives of the filters in the first filterbank. Thinking of this in the time domain, the first filterbank contains filters that have a sinc shape to them. We want to align the output signal to be sampled at exactly the peak of the sinc shape. The derivative of the sinc contains a zero at the maximum point of the sinc (sinc(0) = 1, sinc(0)' = 0). Furthermore, the region around the zero point is relatively linear. We make use of this fact to generate the error signal.

    If the signal out of the derivative filters is d_i[n] for the ith filter, and the output of the matched filter is x_i[n], we calculate the error as: e[n] = (Re{x_i[n]} * Re{d_i[n]} + Im{x_i[n]} * Im{d_i[n]}) / 2.0 This equation averages the error in the real and imaginary parts. There are two reasons we multiply by the signal itself. First, if the symbol could be positive or negative going, but we want the error term to always tell us to go in the same direction depending on which side of the zero point we are on. The sign of x_i[n] adjusts the error term to do this. Second, the magnitude of x_i[n] scales the error term depending on the symbol's amplitude, so larger signals give us a stronger error term because we have more confidence in that symbol's value. Using the magnitude of x_i[n] instead of just the sign is especially good for signals with low SNR.

    The error signal, e[n], gives us a value proportional to how far away from the zero point we are in the derivative signal. We want to drive this value to zero, so we set up a second order loop. We have two variables for this loop; d_k is the filter number in the filterbank we are on and d_rate is the rate which we travel through the filters in the steady state. That is, due to the natural clock differences between the transmitter and receiver, d_rate represents that difference and would traverse the filter phase paths to keep the receiver locked. Thinking of this as a second-order PLL, the d_rate is the frequency and d_k is the phase. So we update d_rate and d_k using the standard loop equations based on two error signals, d_alpha and d_beta. We have these two values set based on each other for a critically damped system, so in the block constructor, we just ask for "gain," which is d_alpha while d_beta is equal to (gain^2)/4.

    The block's parameters are:

    Build the polyphase filterbank timing synchronizer.
    """
  return _digital_swig.pfb_clock_sync_fff(*args, **kwargs)
class digital_pn_correlator_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_pn_correlator_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_pn_correlator_cc_sptr
        __init__(self,  p) -> digital_pn_correlator_cc_sptr
        """
        this = _digital_swig.new_digital_pn_correlator_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_pn_correlator_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_pn_correlator_cc_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_pn_correlator_cc_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_pn_correlator_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_pn_correlator_cc_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_pn_correlator_cc_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_pn_correlator_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_pn_correlator_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_pn_correlator_cc_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_pn_correlator_cc_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_pn_correlator_cc_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_pn_correlator_cc_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_pn_correlator_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_pn_correlator_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_pn_correlator_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_pn_correlator_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_pn_correlator_cc_sptr_check_topology(self, *args, **kwargs)

digital_pn_correlator_cc_sptr_swigregister = _digital_swig.digital_pn_correlator_cc_sptr_swigregister
digital_pn_correlator_cc_sptr_swigregister(digital_pn_correlator_cc_sptr)

digital_pn_correlator_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def pn_correlator_cc(*args, **kwargs):
  """
    pn_correlator_cc(int degree, int mask = 0, int seed = 1) -> digital_pn_correlator_cc_sptr

    PN code sequential search correlator.

    Receives complex baseband signal, outputs complex correlation against reference PN code, one sample per PN code period. The PN sequence is generated using a GLFSR.

    Args:
        degree : Degree of shift register must be in [1, 32]. If mask is 0, the degree determines a default mask (see digital_impl_glfsr.cc for the mapping).
        repeat : Set to repeat sequence.
        mask : Allows a user-defined bit mask for indexes of the shift register to feed back.
        seed : Initial setting for values in shift register.
    """
  return _digital_swig.pn_correlator_cc(*args, **kwargs)
class digital_probe_density_b_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_probe_density_b)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_probe_density_b_sptr
        __init__(self,  p) -> digital_probe_density_b_sptr
        """
        this = _digital_swig.new_digital_probe_density_b_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_probe_density_b_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_probe_density_b_sptr
    __del__ = lambda self : None;
    def density(self):
        """
        density(self) -> double

        Returns the current density value.
        """
        return _digital_swig.digital_probe_density_b_sptr_density(self)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(self, double alpha)

        Set the average filter constant.
        """
        return _digital_swig.digital_probe_density_b_sptr_set_alpha(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_probe_density_b_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_probe_density_b_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_probe_density_b_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_probe_density_b_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_probe_density_b_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_probe_density_b_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_probe_density_b_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_probe_density_b_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_probe_density_b_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_probe_density_b_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_probe_density_b_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_probe_density_b_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_probe_density_b_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_probe_density_b_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_probe_density_b_sptr_check_topology(self, *args, **kwargs)

digital_probe_density_b_sptr_swigregister = _digital_swig.digital_probe_density_b_sptr_swigregister
digital_probe_density_b_sptr_swigregister(digital_probe_density_b_sptr)

digital_probe_density_b_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def probe_density_b(*args, **kwargs):
  """
    probe_density_b(double alpha) -> digital_probe_density_b_sptr

    This block maintains a running average of the input stream and makes it available as an accessor function. The input stream is type unsigned char.

    If you send this block a stream of unpacked bytes, it will tell you what the bit density is.

    Args:
        alpha : Average filter constant
    """
  return _digital_swig.probe_density_b(*args, **kwargs)
class digital_probe_mpsk_snr_est_c_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_probe_mpsk_snr_est_c)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_probe_mpsk_snr_est_c_sptr
        __init__(self,  p) -> digital_probe_mpsk_snr_est_c_sptr
        """
        this = _digital_swig.new_digital_probe_mpsk_snr_est_c_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_probe_mpsk_snr_est_c_sptr
    __del__ = lambda self : None;
    def snr(self):
        """
        snr(self) -> double

        Return the estimated signal-to-noise ratio in decibels.
        """
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_snr(self)

    def type(self):
        """
        type(self) -> snr_est_type_t

        Return the type of estimator in use.
        """
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_type(self)

    def msg_nsample(self):
        """
        msg_nsample(self) -> int

        Return how many samples between SNR messages.
        """
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_msg_nsample(self)

    def alpha(self):
        """
        alpha(self) -> double

        Get the running-average coefficient.
        """
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_alpha(self)

    def set_type(self, *args, **kwargs):
        """
        set_type(self, snr_est_type_t t)

        Set type of estimator to use.
        """
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_set_type(self, *args, **kwargs)

    def set_msg_nsample(self, *args, **kwargs):
        """
        set_msg_nsample(self, int n)

        Set the number of samples between SNR messages.
        """
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_set_msg_nsample(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(self, double alpha)

        Set the running-average coefficient.
        """
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_set_alpha(self, *args, **kwargs)

    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_probe_mpsk_snr_est_c_sptr_check_topology(self, *args, **kwargs)

digital_probe_mpsk_snr_est_c_sptr_swigregister = _digital_swig.digital_probe_mpsk_snr_est_c_sptr_swigregister
digital_probe_mpsk_snr_est_c_sptr_swigregister(digital_probe_mpsk_snr_est_c_sptr)

digital_probe_mpsk_snr_est_c_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def probe_mpsk_snr_est_c(*args, **kwargs):
  """
    probe_mpsk_snr_est_c(snr_est_type_t type, int msg_nsamples = 10000, double alpha = 0.001) -> digital_probe_mpsk_snr_est_c_sptr

    A probe for computing SNR of a signal.

    This is a probe block (a sink) that can be used to monitor and retrieve estimations of the signal SNR. This probe is designed for use with M-PSK signals especially. The type of estimator is specified as the  parameter in the constructor. The estimators tend to trade off performance for accuracy, although experimentation should be done to figure out the right approach for a given implementation. Further, the current set of estimators are designed and proven theoretically under AWGN conditions; some amount of error should be assumed and/or estimated for real channel conditions.

    Factory function returning shared pointer of this class

    Parameters:
    """
  return _digital_swig.probe_mpsk_snr_est_c(*args, **kwargs)
class digital_scrambler_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_scrambler_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_scrambler_bb_sptr
        __init__(self,  p) -> digital_scrambler_bb_sptr
        """
        this = _digital_swig.new_digital_scrambler_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_scrambler_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_scrambler_bb_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_scrambler_bb_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_scrambler_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_scrambler_bb_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_scrambler_bb_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_scrambler_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_scrambler_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_scrambler_bb_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_scrambler_bb_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_scrambler_bb_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_scrambler_bb_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_scrambler_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_scrambler_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_scrambler_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_scrambler_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_scrambler_bb_sptr_check_topology(self, *args, **kwargs)

digital_scrambler_bb_sptr_swigregister = _digital_swig.digital_scrambler_bb_sptr_swigregister
digital_scrambler_bb_sptr_swigregister(digital_scrambler_bb_sptr)

digital_scrambler_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def scrambler_bb(*args, **kwargs):
  """
    scrambler_bb(int mask, int seed, int len) -> digital_scrambler_bb_sptr

    Scramble an input stream using an LFSR. This block works on the LSB only of the input data stream, i.e., on an "unpacked binary" stream, and produces the same format on its output.

    Args:
        mask : Polynomial mask for LFSR
        seed : Initial shift register contents
        len : Shift register length
    """
  return _digital_swig.scrambler_bb(*args, **kwargs)
class digital_simple_framer_sptr(object):
    """Proxy of C++ boost::shared_ptr<(digital_simple_framer)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> digital_simple_framer_sptr
        __init__(self,  p) -> digital_simple_framer_sptr
        """
        this = _digital_swig.new_digital_simple_framer_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _digital_swig.digital_simple_framer_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_digital_simple_framer_sptr
    __del__ = lambda self : None;
    def history(self):
        """history(self) -> unsigned int"""
        return _digital_swig.digital_simple_framer_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _digital_swig.digital_simple_framer_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(self) -> double"""
        return _digital_swig.digital_simple_framer_sptr_relative_rate(self)

    def start(self):
        """start(self) -> bool"""
        return _digital_swig.digital_simple_framer_sptr_start(self)

    def stop(self):
        """stop(self) -> bool"""
        return _digital_swig.digital_simple_framer_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.digital_simple_framer_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.digital_simple_framer_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _digital_swig.digital_simple_framer_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _digital_swig.digital_simple_framer_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _digital_swig.digital_simple_framer_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_simple_framer_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _digital_swig.digital_simple_framer_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _digital_swig.digital_simple_framer_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _digital_swig.digital_simple_framer_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.digital_simple_framer_sptr_check_topology(self, *args, **kwargs)

digital_simple_framer_sptr_swigregister = _digital_swig.digital_simple_framer_sptr_swigregister
digital_simple_framer_sptr_swigregister(digital_simple_framer_sptr)

digital_simple_framer_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id ())


def simple_framer(*args, **kwargs):
  """
    simple_framer(int payload_bytesize) -> digital_simple_framer_sptr

    add sync field, seq number and command field to payload

    Takes in enough samples to create a full output frame. The frame is prepended with the GRSF_SYNC (defind in digital_simple_framer_sync.h) and an 8-bit sequence number.

    Args:
        payload_bytesize : The size of the payload in bytes.
    """
  return _digital_swig.simple_framer(*args, **kwargs)


