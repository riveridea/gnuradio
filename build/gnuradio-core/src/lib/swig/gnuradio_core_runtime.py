# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_gnuradio_core_runtime', [dirname(__file__)])
        except ImportError:
            import _gnuradio_core_runtime
            return _gnuradio_core_runtime
        if fp is not None:
            try:
                _mod = imp.load_module('_gnuradio_core_runtime', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _gnuradio_core_runtime = swig_import_helper()
    del swig_import_helper
else:
    import _gnuradio_core_runtime
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(object):
    """Proxy of C++ swig::SwigPyIterator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gnuradio_core_runtime.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(self) -> PyObject"""
        return _gnuradio_core_runtime.SwigPyIterator_value(self)

    def incr(self, n = 1):
        """incr(self, size_t n = 1) -> SwigPyIterator"""
        return _gnuradio_core_runtime.SwigPyIterator_incr(self, n)

    def decr(self, n = 1):
        """decr(self, size_t n = 1) -> SwigPyIterator"""
        return _gnuradio_core_runtime.SwigPyIterator_decr(self, n)

    def distance(self, *args, **kwargs):
        """distance(self, SwigPyIterator x) -> ptrdiff_t"""
        return _gnuradio_core_runtime.SwigPyIterator_distance(self, *args, **kwargs)

    def equal(self, *args, **kwargs):
        """equal(self, SwigPyIterator x) -> bool"""
        return _gnuradio_core_runtime.SwigPyIterator_equal(self, *args, **kwargs)

    def copy(self):
        """copy(self) -> SwigPyIterator"""
        return _gnuradio_core_runtime.SwigPyIterator_copy(self)

    def next(self):
        """next(self) -> PyObject"""
        return _gnuradio_core_runtime.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(self) -> PyObject"""
        return _gnuradio_core_runtime.SwigPyIterator___next__(self)

    def previous(self):
        """previous(self) -> PyObject"""
        return _gnuradio_core_runtime.SwigPyIterator_previous(self)

    def advance(self, *args, **kwargs):
        """advance(self, ptrdiff_t n) -> SwigPyIterator"""
        return _gnuradio_core_runtime.SwigPyIterator_advance(self, *args, **kwargs)

    def __eq__(self, *args, **kwargs):
        """__eq__(self, SwigPyIterator x) -> bool"""
        return _gnuradio_core_runtime.SwigPyIterator___eq__(self, *args, **kwargs)

    def __ne__(self, *args, **kwargs):
        """__ne__(self, SwigPyIterator x) -> bool"""
        return _gnuradio_core_runtime.SwigPyIterator___ne__(self, *args, **kwargs)

    def __iadd__(self, *args, **kwargs):
        """__iadd__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _gnuradio_core_runtime.SwigPyIterator___iadd__(self, *args, **kwargs)

    def __isub__(self, *args, **kwargs):
        """__isub__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _gnuradio_core_runtime.SwigPyIterator___isub__(self, *args, **kwargs)

    def __add__(self, *args, **kwargs):
        """__add__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _gnuradio_core_runtime.SwigPyIterator___add__(self, *args, **kwargs)

    def __sub__(self, *args):
        """
        __sub__(self, ptrdiff_t n) -> SwigPyIterator
        __sub__(self, SwigPyIterator x) -> ptrdiff_t
        """
        return _gnuradio_core_runtime.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _gnuradio_core_runtime.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

sizeof_char = _gnuradio_core_runtime.sizeof_char
sizeof_short = _gnuradio_core_runtime.sizeof_short
sizeof_int = _gnuradio_core_runtime.sizeof_int
sizeof_float = _gnuradio_core_runtime.sizeof_float
sizeof_double = _gnuradio_core_runtime.sizeof_double
sizeof_gr_complex = _gnuradio_core_runtime.sizeof_gr_complex
class gr_io_signature_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_io_signature)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_io_signature_sptr
        __init__(self, gr_io_signature p) -> gr_io_signature_sptr
        """
        this = _gnuradio_core_runtime.new_gr_io_signature_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self) -> gr_io_signature"""
        return _gnuradio_core_runtime.gr_io_signature_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_io_signature_sptr
    __del__ = lambda self : None;
    def min_streams(self):
        """min_streams(self) -> int"""
        return _gnuradio_core_runtime.gr_io_signature_sptr_min_streams(self)

    def max_streams(self):
        """max_streams(self) -> int"""
        return _gnuradio_core_runtime.gr_io_signature_sptr_max_streams(self)

    def sizeof_stream_item(self, *args, **kwargs):
        """sizeof_stream_item(self, int index) -> int"""
        return _gnuradio_core_runtime.gr_io_signature_sptr_sizeof_stream_item(self, *args, **kwargs)

    def sizeof_stream_items(self):
        """sizeof_stream_items(self) -> __dummy_3__"""
        return _gnuradio_core_runtime.gr_io_signature_sptr_sizeof_stream_items(self)

gr_io_signature_sptr_swigregister = _gnuradio_core_runtime.gr_io_signature_sptr_swigregister
gr_io_signature_sptr_swigregister(gr_io_signature_sptr)


def io_signature(*args, **kwargs):
  """
    io_signature(int min_streams, int max_streams, int sizeof_stream_item) -> gr_io_signature_sptr

    i/o signature for input and output ports.

    misc

    Create an i/o signature.
    """
  return _gnuradio_core_runtime.io_signature(*args, **kwargs)

def io_signature2(*args, **kwargs):
  """
    io_signature2(int min_streams, int max_streams, int sizeof_stream_item1, 
        int sizeof_stream_item2) -> gr_io_signature_sptr

    Create an i/o signature.
    """
  return _gnuradio_core_runtime.io_signature2(*args, **kwargs)

def io_signature3(*args, **kwargs):
  """
    io_signature3(int min_streams, int max_streams, int sizeof_stream_item1, 
        int sizeof_stream_item2, int sizeof_stream_item3) -> gr_io_signature_sptr

    Create an i/o signature.
    """
  return _gnuradio_core_runtime.io_signature3(*args, **kwargs)

def io_signaturev(*args, **kwargs):
  """
    io_signaturev(int min_streams, int max_streams, __dummy_3__ sizeof_stream_items) -> gr_io_signature_sptr

    Create an i/o signature.

    If there are more streams than there are entries in sizeof_stream_items, the value of the last entry in sizeof_stream_items is used for the missing values. sizeof_stream_items must contain at least 1 entry.
    """
  return _gnuradio_core_runtime.io_signaturev(*args, **kwargs)
class gr_io_signature(object):
    """
    i/o signature for input and output ports.

    misc

    Create an i/o signature.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_io_signature
    __del__ = lambda self : None;
    def min_streams(self):
        """min_streams(self) -> int"""
        return _gnuradio_core_runtime.gr_io_signature_min_streams(self)

    def max_streams(self):
        """max_streams(self) -> int"""
        return _gnuradio_core_runtime.gr_io_signature_max_streams(self)

    def sizeof_stream_item(self, *args, **kwargs):
        """sizeof_stream_item(self, int index) -> int"""
        return _gnuradio_core_runtime.gr_io_signature_sizeof_stream_item(self, *args, **kwargs)

    def sizeof_stream_items(self):
        """sizeof_stream_items(self) -> __dummy_3__"""
        return _gnuradio_core_runtime.gr_io_signature_sizeof_stream_items(self)

gr_io_signature_swigregister = _gnuradio_core_runtime.gr_io_signature_swigregister
gr_io_signature_swigregister(gr_io_signature)

class gr_buffer_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_buffer)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_buffer_sptr
        __init__(self,  p) -> gr_buffer_sptr
        """
        this = _gnuradio_core_runtime.new_gr_buffer_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_runtime.gr_buffer_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_buffer_sptr
    __del__ = lambda self : None;
gr_buffer_sptr_swigregister = _gnuradio_core_runtime.gr_buffer_sptr_swigregister
gr_buffer_sptr_swigregister(gr_buffer_sptr)


def buffer(*args, **kwargs):
  """
    buffer(int nitems, size_t sizeof_item, gr_block_sptr link) -> gr_buffer_sptr

    Single writer, multiple reader fifo.

    Allocate a buffer that holds at least  of size .

    The total size of the buffer will be rounded up to a system dependent boundary. This is typically the system page size, but under MS windows is 64KB.
    """
  return _gnuradio_core_runtime.buffer(*args, **kwargs)
class gr_buffer_reader_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_buffer_reader)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_buffer_reader_sptr
        __init__(self,  p) -> gr_buffer_reader_sptr
        """
        this = _gnuradio_core_runtime.new_gr_buffer_reader_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_runtime.gr_buffer_reader_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_buffer_reader_sptr
    __del__ = lambda self : None;
gr_buffer_reader_sptr_swigregister = _gnuradio_core_runtime.gr_buffer_reader_sptr_swigregister
gr_buffer_reader_sptr_swigregister(gr_buffer_reader_sptr)


def buffer_add_reader(*args, **kwargs):
  """
    buffer_add_reader(gr_buffer_sptr buf, int nzero_preload, gr_block_sptr link) -> gr_buffer_reader_sptr

    Create a new gr_buffer_reader and attach it to buffer .
    """
  return _gnuradio_core_runtime.buffer_add_reader(*args, **kwargs)

def buffer_ncurrently_allocated():
  """
    buffer_ncurrently_allocated() -> long

    returns # of gr_buffers currently allocated
    """
  return _gnuradio_core_runtime.buffer_ncurrently_allocated()

def buffer_reader_ncurrently_allocated():
  """
    buffer_reader_ncurrently_allocated() -> long

    returns # of gr_buffer_readers currently allocated
    """
  return _gnuradio_core_runtime.buffer_reader_ncurrently_allocated()
class gr_basic_block_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_basic_block)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_basic_block_sptr
        __init__(self, gr_basic_block p) -> gr_basic_block_sptr
        """
        this = _gnuradio_core_runtime.new_gr_basic_block_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self) -> gr_basic_block"""
        return _gnuradio_core_runtime.gr_basic_block_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_basic_block_sptr
    __del__ = lambda self : None;
    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_runtime.gr_basic_block_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_runtime.gr_basic_block_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_runtime.gr_basic_block_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_runtime.gr_basic_block_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_runtime.gr_basic_block_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """
        check_topology(self, int ninputs, int noutputs) -> bool

        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr_io_signatures.
        """
        return _gnuradio_core_runtime.gr_basic_block_sptr_check_topology(self, *args, **kwargs)

gr_basic_block_sptr_swigregister = _gnuradio_core_runtime.gr_basic_block_sptr_swigregister
gr_basic_block_sptr_swigregister(gr_basic_block_sptr)

class x_vector_gr_basic_block_sptr(object):
    """Proxy of C++ std::vector<(gr_basic_block_sptr)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr___bool__(self)

    def __len__(self):
        """__len__(self) -> std::vector<(boost::shared_ptr<(gr_basic_block)>)>::size_type"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr___len__(self)

    def pop(self):
        """pop(self) -> std::vector<(boost::shared_ptr<(gr_basic_block)>)>::value_type"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_pop(self)

    def __getslice__(self, *args, **kwargs):
        """
        __getslice__(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::difference_type i, 
            std::vector<(boost::shared_ptr<(gr_basic_block)>)>::difference_type j) -> x_vector_gr_basic_block_sptr
        """
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr___getslice__(self, *args, **kwargs)

    def __setslice__(self, *args, **kwargs):
        """
        __setslice__(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::difference_type i, 
            std::vector<(boost::shared_ptr<(gr_basic_block)>)>::difference_type j, 
            x_vector_gr_basic_block_sptr v = std::vector< boost::shared_ptr< gr_basic_block >,std::allocator< boost::shared_ptr< gr_basic_block > > >())
        """
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr___setslice__(self, *args, **kwargs)

    def __delslice__(self, *args, **kwargs):
        """
        __delslice__(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::difference_type i, 
            std::vector<(boost::shared_ptr<(gr_basic_block)>)>::difference_type j)
        """
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr___delslice__(self, *args, **kwargs)

    def __delitem__(self, *args):
        """
        __delitem__(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> x_vector_gr_basic_block_sptr
        __getitem__(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::difference_type i) -> std::vector<(boost::shared_ptr<(gr_basic_block)>)>::value_type
        """
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, x_vector_gr_basic_block_sptr v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::difference_type i, 
            std::vector<(boost::shared_ptr<(gr_basic_block)>)>::value_type x)
        """
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr___setitem__(self, *args)

    def append(self, *args, **kwargs):
        """append(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::value_type x)"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_append(self, *args, **kwargs)

    def empty(self):
        """empty(self) -> bool"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_empty(self)

    def size(self):
        """size(self) -> std::vector<(boost::shared_ptr<(gr_basic_block)>)>::size_type"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_size(self)

    def clear(self):
        """clear(self)"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_clear(self)

    def swap(self, *args, **kwargs):
        """swap(self, x_vector_gr_basic_block_sptr v)"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_swap(self, *args, **kwargs)

    def get_allocator(self):
        """get_allocator(self) -> std::vector<(boost::shared_ptr<(gr_basic_block)>)>::allocator_type"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_get_allocator(self)

    def begin(self):
        """begin(self) -> std::vector<(boost::shared_ptr<(gr_basic_block)>)>::iterator"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_begin(self)

    def end(self):
        """end(self) -> std::vector<(boost::shared_ptr<(gr_basic_block)>)>::iterator"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_end(self)

    def rbegin(self):
        """rbegin(self) -> std::vector<(boost::shared_ptr<(gr_basic_block)>)>::reverse_iterator"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_rbegin(self)

    def rend(self):
        """rend(self) -> std::vector<(boost::shared_ptr<(gr_basic_block)>)>::reverse_iterator"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_pop_back(self)

    def erase(self, *args):
        """
        erase(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::iterator pos) -> std::vector<(boost::shared_ptr<(gr_basic_block)>)>::iterator
        erase(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::iterator first, 
            std::vector<(boost::shared_ptr<(gr_basic_block)>)>::iterator last) -> std::vector<(boost::shared_ptr<(gr_basic_block)>)>::iterator
        """
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> x_vector_gr_basic_block_sptr
        __init__(self, x_vector_gr_basic_block_sptr arg0) -> x_vector_gr_basic_block_sptr
        __init__(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::size_type size) -> x_vector_gr_basic_block_sptr
        __init__(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::size_type size, 
            std::vector<(boost::shared_ptr<(gr_basic_block)>)>::value_type value) -> x_vector_gr_basic_block_sptr
        """
        this = _gnuradio_core_runtime.new_x_vector_gr_basic_block_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args, **kwargs):
        """push_back(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::value_type x)"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_push_back(self, *args, **kwargs)

    def front(self):
        """front(self) -> std::vector<(boost::shared_ptr<(gr_basic_block)>)>::value_type"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_front(self)

    def back(self):
        """back(self) -> std::vector<(boost::shared_ptr<(gr_basic_block)>)>::value_type"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_back(self)

    def assign(self, *args, **kwargs):
        """
        assign(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::size_type n, 
            std::vector<(boost::shared_ptr<(gr_basic_block)>)>::value_type x)
        """
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_assign(self, *args, **kwargs)

    def resize(self, *args):
        """
        resize(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::size_type new_size)
        resize(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::size_type new_size, 
            std::vector<(boost::shared_ptr<(gr_basic_block)>)>::value_type x)
        """
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::iterator pos, 
            std::vector<(boost::shared_ptr<(gr_basic_block)>)>::value_type x) -> std::vector<(boost::shared_ptr<(gr_basic_block)>)>::iterator
        insert(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::iterator pos, 
            std::vector<(boost::shared_ptr<(gr_basic_block)>)>::size_type n, 
            std::vector<(boost::shared_ptr<(gr_basic_block)>)>::value_type x)
        """
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_insert(self, *args)

    def reserve(self, *args, **kwargs):
        """reserve(self, std::vector<(boost::shared_ptr<(gr_basic_block)>)>::size_type n)"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_reserve(self, *args, **kwargs)

    def capacity(self):
        """capacity(self) -> std::vector<(boost::shared_ptr<(gr_basic_block)>)>::size_type"""
        return _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_capacity(self)

    __swig_destroy__ = _gnuradio_core_runtime.delete_x_vector_gr_basic_block_sptr
    __del__ = lambda self : None;
x_vector_gr_basic_block_sptr_swigregister = _gnuradio_core_runtime.x_vector_gr_basic_block_sptr_swigregister
x_vector_gr_basic_block_sptr_swigregister(x_vector_gr_basic_block_sptr)

class gr_basic_block(object):
    """
    The abstract base class for all signal processing blocks.

    Basic blocks are the bare abstraction of an entity that has a name, a set of inputs and outputs, and a message queue. These are never instantiated directly; rather, this is the abstract parent class of both gr_hier_block, which is a recursive container, and gr_block, which implements actual signal processing functions.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_basic_block
    __del__ = lambda self : None;
    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_runtime.gr_basic_block_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_runtime.gr_basic_block_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_runtime.gr_basic_block_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_runtime.gr_basic_block_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_runtime.gr_basic_block_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """
        check_topology(self, int ninputs, int noutputs) -> bool

        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr_io_signatures.
        """
        return _gnuradio_core_runtime.gr_basic_block_check_topology(self, *args, **kwargs)

gr_basic_block_swigregister = _gnuradio_core_runtime.gr_basic_block_swigregister
gr_basic_block_swigregister(gr_basic_block)


def block_ncurrently_allocated():
  """block_ncurrently_allocated() -> long"""
  return _gnuradio_core_runtime.block_ncurrently_allocated()
gr_basic_block_sptr.__repr__ = lambda self: "<gr_basic_block %s (%d)>" % (self.name(), self.unique_id ())

class gr_block_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_block)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_block_sptr
        __init__(self, gr_block p) -> gr_block_sptr
        """
        this = _gnuradio_core_runtime.new_gr_block_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self) -> gr_block"""
        return _gnuradio_core_runtime.gr_block_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_block_sptr
    __del__ = lambda self : None;
    def history(self):
        """
        history(self) -> unsigned int

        Assume block computes y_i = f(x_i, x_i-1, x_i-2, x_i-3...) History is the number of x_i's that are examined to produce one y_i. This comes in handy for FIR filters, where we use history to ensure that our input contains the appropriate "history" for the filter. History should be equal to the number of filter taps.
        """
        return _gnuradio_core_runtime.gr_block_sptr_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_runtime.gr_block_sptr_output_multiple(self)

    def relative_rate(self):
        """
        relative_rate(self) -> double

        return the approximate output rate / input rate
        """
        return _gnuradio_core_runtime.gr_block_sptr_relative_rate(self)

    def start(self):
        """
        start(self) -> bool

        Called to enable drivers, etc for i/o devices.

        This allows a block to enable an associated driver to begin transfering data just before we start to execute the scheduler. The end result is that this reduces latency in the pipeline when dealing with audio devices, usrps, etc.
        """
        return _gnuradio_core_runtime.gr_block_sptr_start(self)

    def stop(self):
        """
        stop(self) -> bool

        Called to disable drivers, etc for i/o devices.
        """
        return _gnuradio_core_runtime.gr_block_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """
        nitems_read(self, unsigned int which_input) -> uint64_t

        Return the number of items read on input stream which_input.
        """
        return _gnuradio_core_runtime.gr_block_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """
        nitems_written(self, unsigned int which_output) -> uint64_t

        Return the number of items written on output stream which_output.
        """
        return _gnuradio_core_runtime.gr_block_sptr_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_runtime.gr_block_sptr_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_runtime.gr_block_sptr_set_detail(self, *args, **kwargs)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_runtime.gr_block_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_runtime.gr_block_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_runtime.gr_block_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_runtime.gr_block_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_runtime.gr_block_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """
        check_topology(self, int ninputs, int noutputs) -> bool

        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr_io_signatures.
        """
        return _gnuradio_core_runtime.gr_block_sptr_check_topology(self, *args, **kwargs)

gr_block_sptr_swigregister = _gnuradio_core_runtime.gr_block_sptr_swigregister
gr_block_sptr_swigregister(gr_block_sptr)

class x_vector_gr_block_sptr(object):
    """Proxy of C++ std::vector<(gr_block_sptr)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr___bool__(self)

    def __len__(self):
        """__len__(self) -> std::vector<(boost::shared_ptr<(gr_block)>)>::size_type"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr___len__(self)

    def pop(self):
        """pop(self) -> std::vector<(boost::shared_ptr<(gr_block)>)>::value_type"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_pop(self)

    def __getslice__(self, *args, **kwargs):
        """
        __getslice__(self, std::vector<(boost::shared_ptr<(gr_block)>)>::difference_type i, 
            std::vector<(boost::shared_ptr<(gr_block)>)>::difference_type j) -> x_vector_gr_block_sptr
        """
        return _gnuradio_core_runtime.x_vector_gr_block_sptr___getslice__(self, *args, **kwargs)

    def __setslice__(self, *args, **kwargs):
        """
        __setslice__(self, std::vector<(boost::shared_ptr<(gr_block)>)>::difference_type i, 
            std::vector<(boost::shared_ptr<(gr_block)>)>::difference_type j, 
            x_vector_gr_block_sptr v = std::vector< boost::shared_ptr< gr_block >,std::allocator< boost::shared_ptr< gr_block > > >())
        """
        return _gnuradio_core_runtime.x_vector_gr_block_sptr___setslice__(self, *args, **kwargs)

    def __delslice__(self, *args, **kwargs):
        """
        __delslice__(self, std::vector<(boost::shared_ptr<(gr_block)>)>::difference_type i, 
            std::vector<(boost::shared_ptr<(gr_block)>)>::difference_type j)
        """
        return _gnuradio_core_runtime.x_vector_gr_block_sptr___delslice__(self, *args, **kwargs)

    def __delitem__(self, *args):
        """
        __delitem__(self, std::vector<(boost::shared_ptr<(gr_block)>)>::difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _gnuradio_core_runtime.x_vector_gr_block_sptr___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> x_vector_gr_block_sptr
        __getitem__(self, std::vector<(boost::shared_ptr<(gr_block)>)>::difference_type i) -> std::vector<(boost::shared_ptr<(gr_block)>)>::value_type
        """
        return _gnuradio_core_runtime.x_vector_gr_block_sptr___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, x_vector_gr_block_sptr v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, std::vector<(boost::shared_ptr<(gr_block)>)>::difference_type i, 
            std::vector<(boost::shared_ptr<(gr_block)>)>::value_type x)
        """
        return _gnuradio_core_runtime.x_vector_gr_block_sptr___setitem__(self, *args)

    def append(self, *args, **kwargs):
        """append(self, std::vector<(boost::shared_ptr<(gr_block)>)>::value_type x)"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_append(self, *args, **kwargs)

    def empty(self):
        """empty(self) -> bool"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_empty(self)

    def size(self):
        """size(self) -> std::vector<(boost::shared_ptr<(gr_block)>)>::size_type"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_size(self)

    def clear(self):
        """clear(self)"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_clear(self)

    def swap(self, *args, **kwargs):
        """swap(self, x_vector_gr_block_sptr v)"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_swap(self, *args, **kwargs)

    def get_allocator(self):
        """get_allocator(self) -> std::vector<(boost::shared_ptr<(gr_block)>)>::allocator_type"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_get_allocator(self)

    def begin(self):
        """begin(self) -> std::vector<(boost::shared_ptr<(gr_block)>)>::iterator"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_begin(self)

    def end(self):
        """end(self) -> std::vector<(boost::shared_ptr<(gr_block)>)>::iterator"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_end(self)

    def rbegin(self):
        """rbegin(self) -> std::vector<(boost::shared_ptr<(gr_block)>)>::reverse_iterator"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_rbegin(self)

    def rend(self):
        """rend(self) -> std::vector<(boost::shared_ptr<(gr_block)>)>::reverse_iterator"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_pop_back(self)

    def erase(self, *args):
        """
        erase(self, std::vector<(boost::shared_ptr<(gr_block)>)>::iterator pos) -> std::vector<(boost::shared_ptr<(gr_block)>)>::iterator
        erase(self, std::vector<(boost::shared_ptr<(gr_block)>)>::iterator first, 
            std::vector<(boost::shared_ptr<(gr_block)>)>::iterator last) -> std::vector<(boost::shared_ptr<(gr_block)>)>::iterator
        """
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> x_vector_gr_block_sptr
        __init__(self, x_vector_gr_block_sptr arg0) -> x_vector_gr_block_sptr
        __init__(self, std::vector<(boost::shared_ptr<(gr_block)>)>::size_type size) -> x_vector_gr_block_sptr
        __init__(self, std::vector<(boost::shared_ptr<(gr_block)>)>::size_type size, 
            std::vector<(boost::shared_ptr<(gr_block)>)>::value_type value) -> x_vector_gr_block_sptr
        """
        this = _gnuradio_core_runtime.new_x_vector_gr_block_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args, **kwargs):
        """push_back(self, std::vector<(boost::shared_ptr<(gr_block)>)>::value_type x)"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_push_back(self, *args, **kwargs)

    def front(self):
        """front(self) -> std::vector<(boost::shared_ptr<(gr_block)>)>::value_type"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_front(self)

    def back(self):
        """back(self) -> std::vector<(boost::shared_ptr<(gr_block)>)>::value_type"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_back(self)

    def assign(self, *args, **kwargs):
        """
        assign(self, std::vector<(boost::shared_ptr<(gr_block)>)>::size_type n, 
            std::vector<(boost::shared_ptr<(gr_block)>)>::value_type x)
        """
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_assign(self, *args, **kwargs)

    def resize(self, *args):
        """
        resize(self, std::vector<(boost::shared_ptr<(gr_block)>)>::size_type new_size)
        resize(self, std::vector<(boost::shared_ptr<(gr_block)>)>::size_type new_size, 
            std::vector<(boost::shared_ptr<(gr_block)>)>::value_type x)
        """
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, std::vector<(boost::shared_ptr<(gr_block)>)>::iterator pos, 
            std::vector<(boost::shared_ptr<(gr_block)>)>::value_type x) -> std::vector<(boost::shared_ptr<(gr_block)>)>::iterator
        insert(self, std::vector<(boost::shared_ptr<(gr_block)>)>::iterator pos, 
            std::vector<(boost::shared_ptr<(gr_block)>)>::size_type n, 
            std::vector<(boost::shared_ptr<(gr_block)>)>::value_type x)
        """
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_insert(self, *args)

    def reserve(self, *args, **kwargs):
        """reserve(self, std::vector<(boost::shared_ptr<(gr_block)>)>::size_type n)"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_reserve(self, *args, **kwargs)

    def capacity(self):
        """capacity(self) -> std::vector<(boost::shared_ptr<(gr_block)>)>::size_type"""
        return _gnuradio_core_runtime.x_vector_gr_block_sptr_capacity(self)

    __swig_destroy__ = _gnuradio_core_runtime.delete_x_vector_gr_block_sptr
    __del__ = lambda self : None;
x_vector_gr_block_sptr_swigregister = _gnuradio_core_runtime.x_vector_gr_block_sptr_swigregister
x_vector_gr_block_sptr_swigregister(x_vector_gr_block_sptr)

class gr_block(gr_basic_block):
    """
    The abstract base class for all 'terminal' processing blocks.

    A signal processing flow is constructed by creating a tree of hierarchical blocks, which at any level may also contain terminal nodes that actually implement signal processing functions. This is the base class for all such leaf nodes.

    Blocks have a set of input streams and output streams. The input_signature and output_signature define the number of input streams and output streams respectively, and the type of the data items in each stream.

    Although blocks may consume data on each input stream at a different rate, all outputs streams must produce data at the same rate. That rate may be different from any of the input rates.

    User derived blocks override two methods, forecast and general_work, to implement their signal processing behavior. forecast is called by the system scheduler to determine how many items are required on each input stream in order to produce a given number of output items.

    general_work is called to perform the signal processing in the block. It reads the input items and writes the output items.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_block
    __del__ = lambda self : None;
    def history(self):
        """
        history(self) -> unsigned int

        Assume block computes y_i = f(x_i, x_i-1, x_i-2, x_i-3...) History is the number of x_i's that are examined to produce one y_i. This comes in handy for FIR filters, where we use history to ensure that our input contains the appropriate "history" for the filter. History should be equal to the number of filter taps.
        """
        return _gnuradio_core_runtime.gr_block_history(self)

    def output_multiple(self):
        """output_multiple(self) -> int"""
        return _gnuradio_core_runtime.gr_block_output_multiple(self)

    def relative_rate(self):
        """
        relative_rate(self) -> double

        return the approximate output rate / input rate
        """
        return _gnuradio_core_runtime.gr_block_relative_rate(self)

    def start(self):
        """
        start(self) -> bool

        Called to enable drivers, etc for i/o devices.

        This allows a block to enable an associated driver to begin transfering data just before we start to execute the scheduler. The end result is that this reduces latency in the pipeline when dealing with audio devices, usrps, etc.
        """
        return _gnuradio_core_runtime.gr_block_start(self)

    def stop(self):
        """
        stop(self) -> bool

        Called to disable drivers, etc for i/o devices.
        """
        return _gnuradio_core_runtime.gr_block_stop(self)

    def nitems_read(self, *args, **kwargs):
        """
        nitems_read(self, unsigned int which_input) -> uint64_t

        Return the number of items read on input stream which_input.
        """
        return _gnuradio_core_runtime.gr_block_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """
        nitems_written(self, unsigned int which_output) -> uint64_t

        Return the number of items written on output stream which_output.
        """
        return _gnuradio_core_runtime.gr_block_nitems_written(self, *args, **kwargs)

    def detail(self):
        """detail(self) -> gr_block_detail_sptr"""
        return _gnuradio_core_runtime.gr_block_detail(self)

    def set_detail(self, *args, **kwargs):
        """set_detail(self, gr_block_detail_sptr detail)"""
        return _gnuradio_core_runtime.gr_block_set_detail(self, *args, **kwargs)

gr_block_swigregister = _gnuradio_core_runtime.gr_block_swigregister
gr_block_swigregister(gr_block)

class gr_block_detail_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_block_detail)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_block_detail_sptr
        __init__(self,  p) -> gr_block_detail_sptr
        """
        this = _gnuradio_core_runtime.new_gr_block_detail_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_runtime.gr_block_detail_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_block_detail_sptr
    __del__ = lambda self : None;
    def ninputs(self):
        """ninputs(self) -> int"""
        return _gnuradio_core_runtime.gr_block_detail_sptr_ninputs(self)

    def noutputs(self):
        """noutputs(self) -> int"""
        return _gnuradio_core_runtime.gr_block_detail_sptr_noutputs(self)

    def sink_p(self):
        """sink_p(self) -> bool"""
        return _gnuradio_core_runtime.gr_block_detail_sptr_sink_p(self)

    def source_p(self):
        """source_p(self) -> bool"""
        return _gnuradio_core_runtime.gr_block_detail_sptr_source_p(self)

    def set_input(self, *args, **kwargs):
        """set_input(self, unsigned int which, gr_buffer_reader_sptr reader)"""
        return _gnuradio_core_runtime.gr_block_detail_sptr_set_input(self, *args, **kwargs)

    def input(self, *args, **kwargs):
        """input(self, unsigned int which) -> gr_buffer_reader_sptr"""
        return _gnuradio_core_runtime.gr_block_detail_sptr_input(self, *args, **kwargs)

    def set_output(self, *args, **kwargs):
        """set_output(self, unsigned int which, gr_buffer_sptr buffer)"""
        return _gnuradio_core_runtime.gr_block_detail_sptr_set_output(self, *args, **kwargs)

    def output(self, *args, **kwargs):
        """output(self, unsigned int which) -> gr_buffer_sptr"""
        return _gnuradio_core_runtime.gr_block_detail_sptr_output(self, *args, **kwargs)

gr_block_detail_sptr_swigregister = _gnuradio_core_runtime.gr_block_detail_sptr_swigregister
gr_block_detail_sptr_swigregister(gr_block_detail_sptr)


def block_detail(*args, **kwargs):
  """
    block_detail(unsigned int ninputs, unsigned int noutputs) -> gr_block_detail_sptr

    Implementation details to support the signal processing abstraction

    This class contains implementation detail that should be "out of sight" of almost all users of GNU Radio. This decoupling also means that we can make changes to the guts without having to recompile everything.
    """
  return _gnuradio_core_runtime.block_detail(*args, **kwargs)

def block_detail_ncurrently_allocated():
  """block_detail_ncurrently_allocated() -> long"""
  return _gnuradio_core_runtime.block_detail_ncurrently_allocated()
class gr_hier_block2_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_hier_block2)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_hier_block2_sptr
        __init__(self, gr_hier_block2 p) -> gr_hier_block2_sptr
        """
        this = _gnuradio_core_runtime.new_gr_hier_block2_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self) -> gr_hier_block2"""
        return _gnuradio_core_runtime.gr_hier_block2_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_hier_block2_sptr
    __del__ = lambda self : None;
    def primitive_connect(self, *args):
        """
        primitive_connect(self, gr_basic_block_sptr block)
        primitive_connect(self, gr_basic_block_sptr src, int src_port, gr_basic_block_sptr dst, 
            int dst_port)

        Add a stand-alone (possibly hierarchical) block to internal graph.

        This adds a gr-block or hierarchical block to the internal graph without wiring it to anything else.
        """
        return _gnuradio_core_runtime.gr_hier_block2_sptr_primitive_connect(self, *args)

    def primitive_disconnect(self, *args):
        """
        primitive_disconnect(self, gr_basic_block_sptr block)
        primitive_disconnect(self, gr_basic_block_sptr src, int src_port, gr_basic_block_sptr dst, 
            int dst_port)

        Remove a gr-block or hierarchical block from the internal flowgraph.

        This removes a gr-block or hierarchical block from the internal flowgraph, disconnecting it from other blocks as needed.
        """
        return _gnuradio_core_runtime.gr_hier_block2_sptr_primitive_disconnect(self, *args)

    def disconnect_all(self):
        """
        disconnect_all(self)

        Disconnect all connections in the internal flowgraph.

        This call removes all output port to input port connections in the internal flowgraph.
        """
        return _gnuradio_core_runtime.gr_hier_block2_sptr_disconnect_all(self)

    def lock(self):
        """
        lock(self)

        Lock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.

        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., gr_block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _gnuradio_core_runtime.gr_hier_block2_sptr_lock(self)

    def unlock(self):
        """
        unlock(self)

        Unlock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.

        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., gr_block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _gnuradio_core_runtime.gr_hier_block2_sptr_unlock(self)

    def to_hier_block2(self):
        """to_hier_block2(self) -> gr_hier_block2_sptr"""
        return _gnuradio_core_runtime.gr_hier_block2_sptr_to_hier_block2(self)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_runtime.gr_hier_block2_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_runtime.gr_hier_block2_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_runtime.gr_hier_block2_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_runtime.gr_hier_block2_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_runtime.gr_hier_block2_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """
        check_topology(self, int ninputs, int noutputs) -> bool

        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr_io_signatures.
        """
        return _gnuradio_core_runtime.gr_hier_block2_sptr_check_topology(self, *args, **kwargs)

gr_hier_block2_sptr_swigregister = _gnuradio_core_runtime.gr_hier_block2_sptr_swigregister
gr_hier_block2_sptr_swigregister(gr_hier_block2_sptr)


def hier_block2_swig(*args, **kwargs):
  """
    hier_block2_swig(string name, gr_io_signature_sptr input_signature, 
        gr_io_signature_sptr output_signature) -> gr_hier_block2_sptr

    Hierarchical container class for gr_block's and gr_hier_block2's.

    public constructor for gr_hier_block2
    """
  return _gnuradio_core_runtime.hier_block2_swig(*args, **kwargs)
class gr_hier_block2(gr_basic_block):
    """
    Hierarchical container class for gr_block's and gr_hier_block2's.

    public constructor for gr_hier_block2
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_hier_block2
    __del__ = lambda self : None;
    def primitive_connect(self, *args):
        """
        primitive_connect(self, gr_basic_block_sptr block)
        primitive_connect(self, gr_basic_block_sptr src, int src_port, gr_basic_block_sptr dst, 
            int dst_port)

        Add a stand-alone (possibly hierarchical) block to internal graph.

        This adds a gr-block or hierarchical block to the internal graph without wiring it to anything else.
        """
        return _gnuradio_core_runtime.gr_hier_block2_primitive_connect(self, *args)

    def primitive_disconnect(self, *args):
        """
        primitive_disconnect(self, gr_basic_block_sptr block)
        primitive_disconnect(self, gr_basic_block_sptr src, int src_port, gr_basic_block_sptr dst, 
            int dst_port)

        Remove a gr-block or hierarchical block from the internal flowgraph.

        This removes a gr-block or hierarchical block from the internal flowgraph, disconnecting it from other blocks as needed.
        """
        return _gnuradio_core_runtime.gr_hier_block2_primitive_disconnect(self, *args)

    def disconnect_all(self):
        """
        disconnect_all(self)

        Disconnect all connections in the internal flowgraph.

        This call removes all output port to input port connections in the internal flowgraph.
        """
        return _gnuradio_core_runtime.gr_hier_block2_disconnect_all(self)

    def lock(self):
        """
        lock(self)

        Lock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.

        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., gr_block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _gnuradio_core_runtime.gr_hier_block2_lock(self)

    def unlock(self):
        """
        unlock(self)

        Unlock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.

        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., gr_block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _gnuradio_core_runtime.gr_hier_block2_unlock(self)

    def to_hier_block2(self):
        """to_hier_block2(self) -> gr_hier_block2_sptr"""
        return _gnuradio_core_runtime.gr_hier_block2_to_hier_block2(self)

gr_hier_block2_swigregister = _gnuradio_core_runtime.gr_hier_block2_swigregister
gr_hier_block2_swigregister(gr_hier_block2)

class gr_single_threaded_scheduler_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_single_threaded_scheduler)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_single_threaded_scheduler_sptr
        __init__(self,  p) -> gr_single_threaded_scheduler_sptr
        """
        this = _gnuradio_core_runtime.new_gr_single_threaded_scheduler_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_runtime.gr_single_threaded_scheduler_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_single_threaded_scheduler_sptr
    __del__ = lambda self : None;
    def stop(self):
        """stop(self)"""
        return _gnuradio_core_runtime.gr_single_threaded_scheduler_sptr_stop(self)

gr_single_threaded_scheduler_sptr_swigregister = _gnuradio_core_runtime.gr_single_threaded_scheduler_sptr_swigregister
gr_single_threaded_scheduler_sptr_swigregister(gr_single_threaded_scheduler_sptr)


def single_threaded_scheduler(*args, **kwargs):
  """
    single_threaded_scheduler(x_vector_gr_block_sptr modules) -> gr_single_threaded_scheduler_sptr

    Simple scheduler for stream computations.
    """
  return _gnuradio_core_runtime.single_threaded_scheduler(*args, **kwargs)

def sts_pyrun(*args, **kwargs):
  """sts_pyrun(gr_single_threaded_scheduler_sptr s)"""
  return _gnuradio_core_runtime.sts_pyrun(*args, **kwargs)
class gr_message_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_message)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_message_sptr
        __init__(self, gr_message p) -> gr_message_sptr
        """
        this = _gnuradio_core_runtime.new_gr_message_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self) -> gr_message"""
        return _gnuradio_core_runtime.gr_message_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_message_sptr
    __del__ = lambda self : None;
    def type(self):
        """type(self) -> long"""
        return _gnuradio_core_runtime.gr_message_sptr_type(self)

    def arg1(self):
        """arg1(self) -> double"""
        return _gnuradio_core_runtime.gr_message_sptr_arg1(self)

    def arg2(self):
        """arg2(self) -> double"""
        return _gnuradio_core_runtime.gr_message_sptr_arg2(self)

    def set_type(self, *args, **kwargs):
        """set_type(self, long type)"""
        return _gnuradio_core_runtime.gr_message_sptr_set_type(self, *args, **kwargs)

    def set_arg1(self, *args, **kwargs):
        """set_arg1(self, double arg1)"""
        return _gnuradio_core_runtime.gr_message_sptr_set_arg1(self, *args, **kwargs)

    def set_arg2(self, *args, **kwargs):
        """set_arg2(self, double arg2)"""
        return _gnuradio_core_runtime.gr_message_sptr_set_arg2(self, *args, **kwargs)

    def length(self):
        """length(self) -> size_t"""
        return _gnuradio_core_runtime.gr_message_sptr_length(self)

    def to_string(self):
        """to_string(self) -> string"""
        return _gnuradio_core_runtime.gr_message_sptr_to_string(self)

gr_message_sptr_swigregister = _gnuradio_core_runtime.gr_message_sptr_swigregister
gr_message_sptr_swigregister(gr_message_sptr)


def message_from_string(*args, **kwargs):
  """message_from_string(string s, long type = 0, double arg1 = 0, double arg2 = 0) -> gr_message_sptr"""
  return _gnuradio_core_runtime.message_from_string(*args, **kwargs)

def message(type = 0, arg1 = 0, arg2 = 0, length = 0):
  """
    message(long type = 0, double arg1 = 0, double arg2 = 0, size_t length = 0) -> gr_message_sptr

    Message class.

    The ideas and method names for adjustable message length were lifted from the click modular router "Packet" class.

    public constructor for gr_message
    """
  return _gnuradio_core_runtime.message(type, arg1, arg2, length)
class gr_message(object):
    """
    Message class.

    The ideas and method names for adjustable message length were lifted from the click modular router "Packet" class.

    public constructor for gr_message
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_message
    __del__ = lambda self : None;
    def type(self):
        """type(self) -> long"""
        return _gnuradio_core_runtime.gr_message_type(self)

    def arg1(self):
        """arg1(self) -> double"""
        return _gnuradio_core_runtime.gr_message_arg1(self)

    def arg2(self):
        """arg2(self) -> double"""
        return _gnuradio_core_runtime.gr_message_arg2(self)

    def set_type(self, *args, **kwargs):
        """set_type(self, long type)"""
        return _gnuradio_core_runtime.gr_message_set_type(self, *args, **kwargs)

    def set_arg1(self, *args, **kwargs):
        """set_arg1(self, double arg1)"""
        return _gnuradio_core_runtime.gr_message_set_arg1(self, *args, **kwargs)

    def set_arg2(self, *args, **kwargs):
        """set_arg2(self, double arg2)"""
        return _gnuradio_core_runtime.gr_message_set_arg2(self, *args, **kwargs)

    def length(self):
        """length(self) -> size_t"""
        return _gnuradio_core_runtime.gr_message_length(self)

    def to_string(self):
        """to_string(self) -> string"""
        return _gnuradio_core_runtime.gr_message_to_string(self)

gr_message_swigregister = _gnuradio_core_runtime.gr_message_swigregister
gr_message_swigregister(gr_message)


def message_ncurrently_allocated():
  """message_ncurrently_allocated() -> long"""
  return _gnuradio_core_runtime.message_ncurrently_allocated()
class gr_msg_handler(object):
    """abstract class of message handlers"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_msg_handler
    __del__ = lambda self : None;
    def handle(self, *args, **kwargs):
        """
        handle(self, gr_message_sptr msg)

        handle
        """
        return _gnuradio_core_runtime.gr_msg_handler_handle(self, *args, **kwargs)

gr_msg_handler_swigregister = _gnuradio_core_runtime.gr_msg_handler_swigregister
gr_msg_handler_swigregister(gr_msg_handler)

class gr_msg_queue_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_msg_queue)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_msg_queue_sptr
        __init__(self,  p) -> gr_msg_queue_sptr
        """
        this = _gnuradio_core_runtime.new_gr_msg_queue_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self)"""
        return _gnuradio_core_runtime.gr_msg_queue_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_msg_queue_sptr
    __del__ = lambda self : None;
    def delete_head_nowait(self):
        """
        delete_head_nowait(self) -> gr_message_sptr

        If there's a message in the q, delete it and return it. If no message is available, return 0.
        """
        return _gnuradio_core_runtime.gr_msg_queue_sptr_delete_head_nowait(self)

    def empty_p(self):
        """
        empty_p(self) -> bool

        is the queue empty?
        """
        return _gnuradio_core_runtime.gr_msg_queue_sptr_empty_p(self)

    def full_p(self):
        """
        full_p(self) -> bool

        is the queue full?
        """
        return _gnuradio_core_runtime.gr_msg_queue_sptr_full_p(self)

    def count(self):
        """
        count(self) -> unsigned int

        return number of messages in queue
        """
        return _gnuradio_core_runtime.gr_msg_queue_sptr_count(self)

    def flush(self):
        """
        flush(self)

        Delete all messages from the queue.
        """
        return _gnuradio_core_runtime.gr_msg_queue_sptr_flush(self)

    def handle(self, *args, **kwargs):
        """
        handle(self, gr_message_sptr msg)

        handle
        """
        return _gnuradio_core_runtime.gr_msg_queue_sptr_handle(self, *args, **kwargs)

gr_msg_queue_sptr_swigregister = _gnuradio_core_runtime.gr_msg_queue_sptr_swigregister
gr_msg_queue_sptr_swigregister(gr_msg_queue_sptr)


def msg_queue(limit = 0):
  """
    msg_queue(unsigned int limit = 0) -> gr_msg_queue_sptr

    thread-safe message queue
    """
  return _gnuradio_core_runtime.msg_queue(limit)

def gr_py_msg_queue__delete_head(*args, **kwargs):
  """gr_py_msg_queue__delete_head(gr_msg_queue_sptr q) -> gr_message_sptr"""
  return _gnuradio_core_runtime.gr_py_msg_queue__delete_head(*args, **kwargs)

def gr_py_msg_queue__insert_tail(*args, **kwargs):
  """gr_py_msg_queue__insert_tail(gr_msg_queue_sptr q, gr_message_sptr msg)"""
  return _gnuradio_core_runtime.gr_py_msg_queue__insert_tail(*args, **kwargs)
gr_msg_queue_sptr.delete_head = gr_py_msg_queue__delete_head
gr_msg_queue_sptr.insert_tail = gr_py_msg_queue__insert_tail
gr_msg_queue_sptr.handle = gr_py_msg_queue__insert_tail

class gr_dispatcher_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_dispatcher)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_dispatcher_sptr
        __init__(self, gr_dispatcher p) -> gr_dispatcher_sptr
        """
        this = _gnuradio_core_runtime.new_gr_dispatcher_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self) -> gr_dispatcher"""
        return _gnuradio_core_runtime.gr_dispatcher_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_dispatcher_sptr
    __del__ = lambda self : None;
    def loop(self, timeout = 10):
        """
        loop(self, double timeout = 10)

        Event dispatching loop.

        Enter a polling loop that only terminates after all gr_select_handlers have been removed.  sets the timeout parameter to the select() call, measured in seconds.
        """
        return _gnuradio_core_runtime.gr_dispatcher_sptr_loop(self, timeout)

gr_dispatcher_sptr_swigregister = _gnuradio_core_runtime.gr_dispatcher_sptr_swigregister
gr_dispatcher_sptr_swigregister(gr_dispatcher_sptr)


def dispatcher():
  """
    dispatcher() -> gr_dispatcher_sptr

    invoke callbacks based on select.
    """
  return _gnuradio_core_runtime.dispatcher()

def dispatcher_singleton():
  """dispatcher_singleton() -> gr_dispatcher_sptr"""
  return _gnuradio_core_runtime.dispatcher_singleton()
class gr_dispatcher(object):
    """invoke callbacks based on select."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_dispatcher
    __del__ = lambda self : None;
    def loop(self, timeout = 10):
        """
        loop(self, double timeout = 10)

        Event dispatching loop.

        Enter a polling loop that only terminates after all gr_select_handlers have been removed.  sets the timeout parameter to the select() call, measured in seconds.
        """
        return _gnuradio_core_runtime.gr_dispatcher_loop(self, timeout)

gr_dispatcher_swigregister = _gnuradio_core_runtime.gr_dispatcher_swigregister
gr_dispatcher_swigregister(gr_dispatcher)

class error_handler(object):
    """abstract error handler"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ERR_DEBUG = _gnuradio_core_runtime.error_handler_ERR_DEBUG
    ERR_MESSAGE = _gnuradio_core_runtime.error_handler_ERR_MESSAGE
    ERR_WARNING = _gnuradio_core_runtime.error_handler_ERR_WARNING
    ERR_ERROR = _gnuradio_core_runtime.error_handler_ERR_ERROR
    ERR_FATAL = _gnuradio_core_runtime.error_handler_ERR_FATAL
    __swig_destroy__ = _gnuradio_core_runtime.delete_error_handler
    __del__ = lambda self : None;
    def default_handler():
        """default_handler() -> error_handler"""
        return _gnuradio_core_runtime.error_handler_default_handler()

    default_handler = staticmethod(default_handler)
    def silent_handler():
        """silent_handler() -> error_handler"""
        return _gnuradio_core_runtime.error_handler_silent_handler()

    silent_handler = staticmethod(silent_handler)
    def has_default_handler():
        """has_default_handler() -> bool"""
        return _gnuradio_core_runtime.error_handler_has_default_handler()

    has_default_handler = staticmethod(has_default_handler)
    def set_default_handler(*args, **kwargs):
        """set_default_handler(error_handler errh)"""
        return _gnuradio_core_runtime.error_handler_set_default_handler(*args, **kwargs)

    set_default_handler = staticmethod(set_default_handler)
    def nwarnings(self):
        """nwarnings(self) -> int"""
        return _gnuradio_core_runtime.error_handler_nwarnings(self)

    def nerrors(self):
        """nerrors(self) -> int"""
        return _gnuradio_core_runtime.error_handler_nerrors(self)

    def reset_counts(self):
        """reset_counts(self)"""
        return _gnuradio_core_runtime.error_handler_reset_counts(self)

    def verror_text(self, *args, **kwargs):
        """verror_text(self, seriousness s, string text)"""
        return _gnuradio_core_runtime.error_handler_verror_text(self, *args, **kwargs)

error_handler_swigregister = _gnuradio_core_runtime.error_handler_swigregister
error_handler_swigregister(error_handler)

def error_handler_default_handler():
  """error_handler_default_handler() -> error_handler"""
  return _gnuradio_core_runtime.error_handler_default_handler()

def error_handler_silent_handler():
  """error_handler_silent_handler() -> error_handler"""
  return _gnuradio_core_runtime.error_handler_silent_handler()

def error_handler_has_default_handler():
  """error_handler_has_default_handler() -> bool"""
  return _gnuradio_core_runtime.error_handler_has_default_handler()

def error_handler_set_default_handler(*args, **kwargs):
  """error_handler_set_default_handler(error_handler errh)"""
  return _gnuradio_core_runtime.error_handler_set_default_handler(*args, **kwargs)

class file_error_handler(object):
    """Proxy of C++ gr_file_error_handler class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, int file_descriptor) -> file_error_handler"""
        this = _gnuradio_core_runtime.new_file_error_handler(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _gnuradio_core_runtime.delete_file_error_handler
    __del__ = lambda self : None;
file_error_handler_swigregister = _gnuradio_core_runtime.file_error_handler_swigregister
file_error_handler_swigregister(file_error_handler)

RT_OK = _gnuradio_core_runtime.RT_OK
RT_NOT_IMPLEMENTED = _gnuradio_core_runtime.RT_NOT_IMPLEMENTED
RT_NO_PRIVS = _gnuradio_core_runtime.RT_NO_PRIVS
RT_OTHER_ERROR = _gnuradio_core_runtime.RT_OTHER_ERROR

def enable_realtime_scheduling():
  """
    enable_realtime_scheduling() -> gr_rt_status_t

    If possible, enable high-priority "real time" scheduling.
    """
  return _gnuradio_core_runtime.enable_realtime_scheduling()
class gr_sync_block(gr_block):
    """
    synchronous 1:1 input to output with history

    Override work to provide the signal processing implementation.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_sync_block
    __del__ = lambda self : None;
gr_sync_block_swigregister = _gnuradio_core_runtime.gr_sync_block_swigregister
gr_sync_block_swigregister(gr_sync_block)

class gr_sync_decimator(gr_sync_block):
    """
    synchronous N:1 input to output with history

    Override work to provide the signal processing implementation.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_sync_decimator
    __del__ = lambda self : None;
gr_sync_decimator_swigregister = _gnuradio_core_runtime.gr_sync_decimator_swigregister
gr_sync_decimator_swigregister(gr_sync_decimator)

class gr_sync_interpolator(gr_sync_block):
    """
    synchronous 1:N input to output with history

    Override work to provide the signal processing implementation.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_sync_interpolator
    __del__ = lambda self : None;
gr_sync_interpolator_swigregister = _gnuradio_core_runtime.gr_sync_interpolator_swigregister
gr_sync_interpolator_swigregister(gr_sync_interpolator)

class gr_top_block_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr_top_block)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> gr_top_block_sptr
        __init__(self, gr_top_block p) -> gr_top_block_sptr
        """
        this = _gnuradio_core_runtime.new_gr_top_block_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(self) -> gr_top_block"""
        return _gnuradio_core_runtime.gr_top_block_sptr___deref__(self)

    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_top_block_sptr
    __del__ = lambda self : None;
    def start(self, max_noutput_items = 100000):
        """
        start(self, int max_noutput_items = 100000)

        Start the contained flowgraph. Creates one or more threads to execute the flow graph. Returns to the caller once the threads are created. Calling start() on a top_block that is already started IS an error.
        """
        return _gnuradio_core_runtime.gr_top_block_sptr_start(self, max_noutput_items)

    def stop(self):
        """
        stop(self)

        Stop the running flowgraph. Notifies each thread created by the scheduler to shutdown, then returns to caller. Calling stop() on a top_block that is already stopped IS NOT an error.
        """
        return _gnuradio_core_runtime.gr_top_block_sptr_stop(self)

    def lock(self):
        """
        lock(self)

        Lock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.

        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., gr_block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _gnuradio_core_runtime.gr_top_block_sptr_lock(self)

    def unlock(self):
        """
        unlock(self)

        Unlock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.

        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., gr_block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _gnuradio_core_runtime.gr_top_block_sptr_unlock(self)

    def dump(self):
        """
        dump(self)

        Displays flattened flowgraph edges and block connectivity
        """
        return _gnuradio_core_runtime.gr_top_block_sptr_dump(self)

    def max_noutput_items(self):
        """
        max_noutput_items(self) -> int

        Get the number of max noutput_items in the flowgraph.
        """
        return _gnuradio_core_runtime.gr_top_block_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """
        set_max_noutput_items(self, int nmax)

        Set the maximum number of noutput_items in the flowgraph.
        """
        return _gnuradio_core_runtime.gr_top_block_sptr_set_max_noutput_items(self, *args, **kwargs)

    def to_top_block(self):
        """to_top_block(self) -> gr_top_block_sptr"""
        return _gnuradio_core_runtime.gr_top_block_sptr_to_top_block(self)

    def primitive_connect(self, *args):
        """
        primitive_connect(self, gr_basic_block_sptr block)
        primitive_connect(self, gr_basic_block_sptr src, int src_port, gr_basic_block_sptr dst, 
            int dst_port)

        Add a stand-alone (possibly hierarchical) block to internal graph.

        This adds a gr-block or hierarchical block to the internal graph without wiring it to anything else.
        """
        return _gnuradio_core_runtime.gr_top_block_sptr_primitive_connect(self, *args)

    def primitive_disconnect(self, *args):
        """
        primitive_disconnect(self, gr_basic_block_sptr block)
        primitive_disconnect(self, gr_basic_block_sptr src, int src_port, gr_basic_block_sptr dst, 
            int dst_port)

        Remove a gr-block or hierarchical block from the internal flowgraph.

        This removes a gr-block or hierarchical block from the internal flowgraph, disconnecting it from other blocks as needed.
        """
        return _gnuradio_core_runtime.gr_top_block_sptr_primitive_disconnect(self, *args)

    def disconnect_all(self):
        """
        disconnect_all(self)

        Disconnect all connections in the internal flowgraph.

        This call removes all output port to input port connections in the internal flowgraph.
        """
        return _gnuradio_core_runtime.gr_top_block_sptr_disconnect_all(self)

    def to_hier_block2(self):
        """to_hier_block2(self) -> gr_hier_block2_sptr"""
        return _gnuradio_core_runtime.gr_top_block_sptr_to_hier_block2(self)

    def name(self):
        """name(self) -> string"""
        return _gnuradio_core_runtime.gr_top_block_sptr_name(self)

    def input_signature(self):
        """input_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_runtime.gr_top_block_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(self) -> gr_io_signature_sptr"""
        return _gnuradio_core_runtime.gr_top_block_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(self) -> long"""
        return _gnuradio_core_runtime.gr_top_block_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(self) -> gr_basic_block_sptr"""
        return _gnuradio_core_runtime.gr_top_block_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """
        check_topology(self, int ninputs, int noutputs) -> bool

        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr_io_signatures.
        """
        return _gnuradio_core_runtime.gr_top_block_sptr_check_topology(self, *args, **kwargs)

gr_top_block_sptr_swigregister = _gnuradio_core_runtime.gr_top_block_sptr_swigregister
gr_top_block_sptr_swigregister(gr_top_block_sptr)


def top_block_swig(*args, **kwargs):
  """
    top_block_swig(string name) -> gr_top_block_sptr

    Top-level hierarchical block representing a flowgraph.
    """
  return _gnuradio_core_runtime.top_block_swig(*args, **kwargs)
class gr_top_block(gr_hier_block2):
    """Top-level hierarchical block representing a flowgraph."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _gnuradio_core_runtime.delete_gr_top_block
    __del__ = lambda self : None;
    def start(self, max_noutput_items = 100000):
        """
        start(self, int max_noutput_items = 100000)

        Start the contained flowgraph. Creates one or more threads to execute the flow graph. Returns to the caller once the threads are created. Calling start() on a top_block that is already started IS an error.
        """
        return _gnuradio_core_runtime.gr_top_block_start(self, max_noutput_items)

    def stop(self):
        """
        stop(self)

        Stop the running flowgraph. Notifies each thread created by the scheduler to shutdown, then returns to caller. Calling stop() on a top_block that is already stopped IS NOT an error.
        """
        return _gnuradio_core_runtime.gr_top_block_stop(self)

    def lock(self):
        """
        lock(self)

        Lock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.

        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., gr_block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _gnuradio_core_runtime.gr_top_block_lock(self)

    def unlock(self):
        """
        unlock(self)

        Unlock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.

        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., gr_block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _gnuradio_core_runtime.gr_top_block_unlock(self)

    def dump(self):
        """
        dump(self)

        Displays flattened flowgraph edges and block connectivity
        """
        return _gnuradio_core_runtime.gr_top_block_dump(self)

    def max_noutput_items(self):
        """
        max_noutput_items(self) -> int

        Get the number of max noutput_items in the flowgraph.
        """
        return _gnuradio_core_runtime.gr_top_block_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """
        set_max_noutput_items(self, int nmax)

        Set the maximum number of noutput_items in the flowgraph.
        """
        return _gnuradio_core_runtime.gr_top_block_set_max_noutput_items(self, *args, **kwargs)

    def to_top_block(self):
        """to_top_block(self) -> gr_top_block_sptr"""
        return _gnuradio_core_runtime.gr_top_block_to_top_block(self)

gr_top_block_swigregister = _gnuradio_core_runtime.gr_top_block_swigregister
gr_top_block_swigregister(gr_top_block)


def top_block_run_unlocked(*args, **kwargs):
  """top_block_run_unlocked(gr_top_block_sptr r)"""
  return _gnuradio_core_runtime.top_block_run_unlocked(*args, **kwargs)

def top_block_wait_unlocked(*args, **kwargs):
  """top_block_wait_unlocked(gr_top_block_sptr r)"""
  return _gnuradio_core_runtime.top_block_wait_unlocked(*args, **kwargs)


